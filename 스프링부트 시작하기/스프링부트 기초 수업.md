# 스프링부트 기초 수업 정리
[강의링크](https://youtu.be/l_jsdZJ6oco?feature=shared)
[수업페이지](https://www.slog.gg/p/13853)


### 목차
[00. REST API 개념](#00-rest-api-개념)
[](#01-세팅)
[](#02-스프링부트)
[](#03-homecontroller-도입)
[](#03-쿼리스트링을-이용한-url-파라미터-받아오기)
[]()
[]()
[]()
[]()
[]()
[]()
[]()
[]()
[]()





---

### 00. REST API 개념
- GET: 자원 조회 -> 사용자 목록 조회
- POST: 자원 생성 -> 사용자 생성
- PUT: 전체 자원 업데이트 -> 사용자 업데이트
- DELETE: 자원 삭제 -> 사용자 삭제


### 01. 세팅
- settings
  - compiler -> Build project auto~
  - Java Compiler -> Additional~ "-parameters" 입력
  - Annotation Processor: Enable 체크
  - Advanced settings: Allow~ 체크


### 02. 스프링부트
- 스프링부트 = 자동전화응답기
  - 서버
  - 끄기 전까지 계속 돌아간다
- 프레임워크: 이미 완성되어있다
  - 개발의 틀
  - 90% 이미 만들어진 것 가져와서 사용 + 10% 문법으로 새로 만듦
  - ex. 로그인 구현: 로그인 라이브러리가 sb에 존재함으로 가져다 사용하면 됨
- 스프링부트는 내부적으로 **Jackson** 라이브러리를 사용
  - 게터 없으면 필드값을 읽을 수 없음
- **직렬화**: 자바 오브젝트를 **JSON**으로 변환
  - JSON으로 변환할 때 게터 메서드를 사용하여 객체 내부 데이터를 가져온다
- **역직렬화**: JSON -> 자바 오브젝트로 변환
  - JSON이 자바 오브젝트로 변환 시, 세터 메서드를 사용하여 객체 내부 데이터 저장
    - 세터가 없으면 JSON 데이터를 객체로 변환하지 못함

즉, 직렬화 = 데이터를 보낼 수 있는 형태로 포장 = 보낼 준비 완료
역직렬화 = 데이터를 포장해서 꺼내는 과정 = 물건 확인

스프링부트가 JSON 사용하는 이유는?
- 웹 브라우저는 서버(스프링부트)와의 데이터를 교환할 때 JSON이 필요하다
  - **JSON은 표준 응답 체계**
- JSON은 가볍고 JS와 호환성도 좋다



### 03. HomeController 도입
```java
@Controller
public class HomeController {
  @GetMapping("/home/main") 
  @ResponseBody 
  public String showHome() {
    return "안녕하세요.";
  }
}
```

- @Controller는 이 클래스가 컨트롤러이고 웹 요청을 받아 작업한다는 것을 명시함
- @GetMapping은 GET으로 어떤 요청의 응답을 가져온다
  - "/home/main"이라는 요청이 들어오면 해당 메서드 실행
- @ResponseBody는 html body에 메서드 실행 리턴값을 응답으로 받아서 보여준다

### 04. home/increase 요청 처리
```java
@Controller
public class HomeController {
  int num; // 인스턴스 변수 만들고 값은 넣지 않는다
  
  public HomeController() {
    num = -1; // 인스턴스 변수에 값을 할당하기 위해 생성사 메서드
  }
  @GetMapping("/home/increase") 
  @ResponseBody
  public int increase() {
    num++; // 브라우저 접속 시마다 +1 전역변수 사용
    return num;
  }
}
```

- 객체를 만들지 않아도 @Controller가 컨테이너를 통해 객체 알아서 만들어 준다
- 스프링부트는 응답 결과를 html body에 모두 문자열로 보여준다
- 웹 브라우저는 무조건 String만 이해한다


### 05. 쿼리스트링을 이용한 URL 파라미터 받아오기
```java
@Controller
public class HomeController {
  @GetMapping("/home/plus")
  @ResponseBody
  public int plus(@RequestParam(defaultValue = "0") int a, int b) { // 매개변수를 써주면 스프링부트가 알아서 파라미터로 인식
    // rq.getIntParam("a", 0); <- 스프링부트는 @RequestParam으로 해결, defaultValue는 무조건 문자열
    // 현재 a만 defaultValue가 있고 b는 없는 상태. b는 생략 불가능
    return a+b; // 문자열만 인식하는 스프링부트이지만 받아온 a,b를 알아서 정수로 인식
  }
}
```

- `/home/plus?a=1&b=2` 쿼리 파라미터, 쿼리 스트링
- @RequestParam(defaultValue = "0") int a로 a의 defaultValue 0으로 설정
- 매개변수명과 쿼리 파라미터는 동일한 이름으로 사용해야 한다


### 06. article, person 클래스(사람 추가)
```java
@Controller
public class HomeController {
  List<Person> people;

  public HomeController() {people = new ArrayList<>();}
  @GetMapping("/home/article")
  @ResponseBody
  public Article showArticle() {
    Article article = new Article(1, "제목1", "내용1");
    return article;
  }

  // 요청 : http://localhost:8080/home/addPerson?name=홍길동&age=11
  // 응답 : 1번 사람이 추가되었습니다.
  @GetMapping("/home/addPerson")
  @ResponseBody
  public String addPerson(String name, int age) { // 응답결과가 문자열이기 때문에 String

    Person p = new Person(name, age); // id 필드가 있지만 넣지 않음. 실제값은 파라미터로 받기 때문에 넣지 않는다
    System.out.println("p " + p);
    people.add(p); // 리스트에 담아줌

    // 실제로 추가된 것이 아니라 메시지 출력된 결과일 뿐
    // 이 메서드 내에 리스트를 만들어 담으면 지역변수이므로 x
    return "%d번 사람이 추가되었습니다.".formatted(p.getId()); // Person 클래스 필드에 id를 만들어주었으므로 id 가져올 수 있음

  }

  @GetMapping("/home/showPeople")
  @ResponseBody
  public List<Person> showPeople() {
    return people;
  }
}

@NoArgsConstructor // 비어있는 생성자 메서드
@AllArgsConstructor
@Data
class Article{
  int id;
  String subject;
  String content;
}

@AllArgsConstructor
@Data // 게터, 세터, ToString
class Person{
  private static int lastId; // lastId를 static으로 생성
  private final int id; // 모든 객체는 고유의 아이디를 가지기 때문에 식별자가 필요하다
  private final String name; // 수정할 일이 없는 정보이기 때문에 private final 붙이고
  private final int age; // private는 게터, 세터가 필수! final은 생성자 메서드 필수!
  static { // static 생성자
    // static은 프로그램 실행 되지마자 딱 한 번 실행됨
    lastId = 0; // lastId 세팅
  }

  // 메서드 오버로딩
  public Person(String name, int age) { // 데이터가 id, name, age 세 개이지만 두 개만 받는 생성자임
    // 어떻게 id를 받아오나
    this(lastId++, name, age); // 생성자 메서드 안에서 this는 자기 자신 생성자메서드
    // this.id = id; 와 같은 것
    // 이로써 객체가 생성될 때마다 id값이 1씩 증가됨
  }
}
```
- @NoArgsConstructor: 비어있는 생성자 메서드
- @Data는 getter, setter, ToString을 모두 포함
- Map
  - Map은 키, 값으로 데이터를 보내줘야 하는데
  - Map을 사용하지 않아도 스프링부트가 알아서 객체를 만들고 데이터를 넣어서 출력하면
  - 키, 값 형태로 보여준다
  - Map에 담는 것 = Article객체를 두 개 만들고 리스트에 담는 것이 동일함 = **SB에서는 Map에 담아 보낼 필요 없이 객체로 담아도 됨**
  - return list하게 되면 주소값이 나오는 게 정상이지만 스프링부트는 알아서 스트링으로 보여줌
- 쿼리 파라미터로 받은 사람 데이터를 담을 클래스로 Person 클래스 생성
- lastId를 static으로 생성하여 알아서 증가할 수 있도록


### 07. 사람 삭제
```java
// 테스트 케이스 생성
  @GetMapping("/home/personTestcase")
  @ResponseBody
  public String personTestcase() {
    people.add(new Person("홍길동", 11));
    people.add(new Person("홍길순", 22));
    people.add(new Person("임꺽정", 33));
    return "테스트 케이스 추가";
  }

  // 요청 : http://localhost:8080/home/removePerson?id=2
  //응답 : 2번 사람이 삭제되었습니다.
  @GetMapping("/home/removePerson")
  @ResponseBody
  public String removePerson(int id) { // 파라미터로 id를 넘겨서 삭제
    // 스트림문법
    // person.getId() == id
    // 위 함수가 참인 요소가 존재하면, 해당 요소를 삭제한다.
    // 해당 함수의 삭제 결과는 true or false
    // 정상적으로 삭제가 이뤄지면 true 반환, 삭제를 실패하면 false 반환
    boolean removed = people.removeIf(person -> person.getId() == id);
    if(!removed) {
      return "%d번 사람이 존재하지 않습니다.".formatted(id);
    }
    return "%d번 사람이 삭제되었습니다.".formatted(id);
  }
```

### 08. 사람 수정
```java
// 요청 : http://localhost:8080/home/modifyPerson?id=1&name=홍홍홍&age=44
// 응답 : 1번 사람이 수정되었습니다.
@GetMapping("/home/modifyPerson")
@ResponseBody
public String modifyPerson(int id, String name, int age) { // 파라미터를 3개 받음
  Person target = people.stream()
      .filter(p -> p.getId() == id) // 해당 녀석이 참인 것만 필터링
      .findFirst() // 찾은 것 중에 하나만 남는데, 그 하나 남은 것을 필터링
      .orElse(null); // 없으면 null 리턴
  if(target == null) {
    return "%d번 사람이 존재하지 않습니다.".formatted(id);
  }
  target.setName(name);
  target.setAge(age); // 수정 완료
  return "%d번 사람이 수정되었습니다.".formatted(id);
}
```

- /home/modifyPerson?id=1&name=홍홍홍&age=44
- 파라미터 입력한 값을 서버에 저장을 해줘야 수정이 됨
- person 클래스는 각 필드를 private로 접근을 제한하기 때문에
- 접근하기 위해 Setter가 필요!
- JSON 라이브러리가 Getter를 통해 데이터를 가져와서 화면에 띄워줌
- JSON -> 자바 오브젝트로 변환해야 한다
- 이때 필요한 것이 Setter
- Setter는 상수처리 = final을 풀어줘야 접근 가능
- id는 고유하기 때문에 final을 풀어줄 필요 없다


### 09. 쿠키 발행 연습
```java
@GetMapping("/home/cookie/increase")
  @ResponseBody
  public int showCookieIncrease(HttpServletRequest req, HttpServletResponse resp) throws IOException{
  // 쿠키를 가지고 브라우저를 구분하기 시작함
  int countInCookie = 0;
  if (req.getCookies() != null) { // null이 아니라는 것 = 쿠키가 이미 들어있다(쿠키가 발행되어 있음)
    countInCookie = Arrays.stream(req.getCookies())
        .filter(cookie -> cookie.getName().equals("count")) // 쿠키를 가져오는데 그 이름이 count
        .map(cookie -> cookie.getValue()) // 쿠키의 value를 가져와라
        .mapToInt(Integer::parseInt) // 가져올 때 형변환
        .findAny() // 찾아서 가져오고
        .orElse(0); // 없으면 0 반환
  }
  int newCountInCookie = countInCookie + 1;
  // 쿠키 발행, countInCookie + 1 + ""은 받은 쿠키+1을 문자열로 변환해준 것
  resp.addCookie(new Cookie("count", newCountInCookie + ""));
  // 쿠폰이 올 때마다 도장 하나씩 찍어주는 구조
  return newCountInCookie;
}
```

- HttpServletRequest req: 받은 편지
- HttpServletResponse resp: 보낼 편지
- SB는 브라우저를 기억하지 못 한다
  - 네이버와 다음을 동일하게 취급 = 개별처리가 안 되고 있다!
  - 서버는 고객을 기억하지(구분하지) 못 한다
  -> **쿠키를 도입하여 브라우저를 구분할 수 있도록!**
1. 브라우저 -> 서버에 요청
   - 최초의 요청에는 쿠폰 미발행
2. 브라우저 -> 서버에 요청
   - 서버에서 쿠폰을 발행해서 보내줌
- 쿠키를 브라우저에서 수정해도 반영된다 = 쿠키를 기억하는 것은 브라우저! 서버가 아니다!
- 카페 도장은 카페에 방문한 손님이 관리하지 직원이 손님을 기억해서 도장을 찍어주는 게 아니다.


### 10. member/login 구현

은행 예시
- 컨트롤러 -> 창구 은행 직원(존재하는 회원인지 유효성 검사)
- 서비스 -> 전산 처리(대출이 가능한지 전산처리)
- 리포지터리 -> DB와 소통하여 전산 결과 저장을 도움
- 제일 처음 컨트롤러를 만들고 컨트롤러에서 서비스를 필드로 소환하여 클래스 추가


```java
@AllArgsConstructor
@Getter
public class RsData { // 위치 base.rsData.RsData
  private final String resultCode; // final 붙으면
  private final String msg; // 생성자 메서드 필수
  public static RsData of(String resultCode, String msg) {
    return new RsData(resultCode, msg); // 생성자 메서드 필요
  }
}
```

final 붙으면 생성자 메서드 필수!

RsData: 객체를 생성할 때 사용되는 메소드
- 객체 생성 후 객체의 초기화를 하는 역할 수행
- 객체를 생성함과 동시에 기억공간이 만들어졌으니 데이터를 저장할수있다.
- 저장하는 행위를 초기화(initialize)라고 한다.
- RsData를 클래스로 만들면 매번 객체 만들어 of메서드 호출하는 것 대신
- of메서드를 static으로 만들어서 더 편하게

```java
// controller 만들면 제일 먼제 @Controller 붙이기
@Controller
public class MemberController {
  private final MemberService memberService;
  public MemberController() {
    memberService = new MemberService();
  }
  @GetMapping("/member/login")
  @ResponseBody
  public RsData login(String username, String password) {
    if(username == null || username.trim().isEmpty()){
      return RsData.of("F-3", "username(을)를 입력해주세요.");
    }
    if(password == null || password.trim().isEmpty()){
      return RsData.of("F-4", "password(을)를 입력해주세요.");
    }
    return memberService.tryLogin(username, password);
  }
}
```

- controller는 판단을 하지 않고 Service에 보내주는 역할
- controller는 유효성 검사해주는 역할

```java
@AllArgsConstructor
@Data
public class Member {
  private static int lastId;
  private final long id; // final이 붙으면 비어있는 생성자 만들 수 없음(@No~)
  private final String username;
  private String password; // 비밀번호는 수정할 수 있기 때문에 final x
  static {
    lastId = 0;
  }
  // username과 password만 만들면 id 자동으로 증가되어 생성되는
  public Member(String username, String password) {
    this(++lastId, username, password);
  }
}
```

- final은 비어있는 생성자 만들 수 없다

```java
@Repository
public class MemberRepository {
  List<Member> members;
  public MemberRepository() {
    members = new ArrayList<>();
    // 테스트데이터 생성
    members.add(new Member("user1", "1234"));
    members.add(new Member("user2", "1234"));
    members.add(new Member("user3", "1234"));
    members.add(new Member("user4", "1234"));
    members.add(new Member("user5", "1234"));
  }
  public Member findByUserName(String username) {
    return members.stream()
        .filter(member -> member.getUsername().equals(username))
        .findFirst()
        .orElse(null);
  }
}
```

```java
@Service
public class MemberService {
  public MemberRepository memberRepository;
  public MemberService() {
    memberRepository = new MemberRepository();
  }
  public RsData tryLogin(String username, String password) {
    // 서비스 입장에서 리포지터리에 username 주면 찾아서 서비스로 보내줘
    Member member = memberRepository.findByUserName(username);
    if (member == null) {
      return RsData.of("F-2", "%s(은)는 존재하지 않는 회원입니다.".formatted(username));
    }
    if(!member.getPassword().equals(password)){
      return RsData.of("F-1", "비밀번호가 일치하지 않습니다");
    }
    return RsData.of("S-1", "%s님 환영합니다.".formatted(username));
  }
}
```

### 11. 스프링 컨테이너: IoC컨테이너 내용 정리

스프링 컨테이너(jsp, db에서의 컨테이너와는 다름)
홈
멤버
- 컨트롤러
- 서비스
- 리포지터리
- DTO -> Entity
- JPA

**IoC컨테이너가 필요한 이유**

HomeController에서 MemberService가 필요한 상황이라면?
- 컨트롤러에서 리포지터리 소환하면 안됨!!
- 서비스 수준에서만 소환 가능
- 컨트롤러는 리포지터리에 명령을 내릴 수 없다.
    - 서비스를 거쳐야 가능함.
      -현재 구조
      [HomeController] [MemberController] 둘다 [MemberService]가 필요한 상황
      home, memberController에서 각각 만드는 것은 메모리 낭비
      memberService 만들 때 memberRepository가 같이 만들어지고 있는 상황(생성자 메서드)
      각각 **memberService 소환할 때마다 memberRepository도 각각** 만들어지고 있는 상황
      => HomeController에서 MemberService를 호출하는 것은 좋지 않다
- 그러나 가끔 다른 컨트롤러에서 다른 서비스를 만드는 경우 발생하기도 함(지금처럼)
  => 그럼 **스프링 컨테이너를 이용해 객체를 공유**하는 방법이 있다

- 스프링부트 안에는 내부적으로 컨테이너가 존재한다 = IOC 컨테이너(공용도구상자)
- memberService를 IOC 컨테이너에서 만들어준다
    - 사용할 때마다 IOC 컨테이너에서 가져와서 쓰면 되니까
        - 원래는 Controller 클래스에 new를 해서 객체 생성했는데
            - Service 맨 위에 @Component, Controller에 @Autowired로 객체 생성하면
                - 매번 new로 객체 생성을 하지 않아도 Component를 Service에 써주면 스프링부트가 알아서 new해준다
                - 그러기 위해 사전 등록을 하는 것 = @Component
        - 그러나, @Service, @Controller에 이미 @Component가 들어있음
        - Ioc컨테이너에 의해 서비스를 관리하겠다 -> 변수 위에 @Autowired만 붙여주면 됨
          **생성자 주입과 필드 주입** == 객체생성을 Ioc컨테이너에 맡김 = 생성자주입을 더 많이 씀
          **@AllArgsConstructor**을 사용하면 생성자주입도 생략 가능

**생성자 주입을 권장(의존성 주입)**
- 필드 주입은 생성시점이 모호하여 nullPointException 발생하기도 함
- 생성자 주입은 생성시점이 정확함(객체 생성시)
- 필드 주입은 final 키워드가 붙지 않아 해당 변수의 값이 수정될 여지도 있음
- 생성자 주입은 final 키워드가 붙어서 수정을 잠근다
- 생성자 주입을 쓰면 롬복(@AllArgsConstructor)로 쓸 수 있으니 편리


### 12. IoC컨테이너를 통한 객체 생성 및 필드 주입과 생성자 주입

```java
@Controller
public class HomeController {
  // 필드 주입
  @Autowired
  private MemberService memberService;
}
```

- **필드 주입**: @Autowired를 붙이면 MemberService 객체를 만들어 memberService와 연결시켜줌

```java
@Controller
@AllArgsConstructor // @AllArgsConstructor을 사용하면 생성자주입 자동으로
public class MemberController {
  private final MemberService memberService; // 생성자 주입 시 final 필수
}
```

- **생성자 주입**: 생상자를 만들어두고 생성자를 주입시키고 있음
- 생성자 주입의 경우 @Autowired 생략 가능
- ```java
  public MemberController(MemberService memberService) {
  // Ioc컨테이너에 의해 만들어진 memberService를 연결만 시켜주면 됨.
  this.memberService = memberService;  }
  ```
- @AllArgsConstructor을 사용하면 생성자주입 자동으로
- @Component: 아래 클래스는 Ioc 컨테이너에 의해 생사소멸이 관리된다.
  - @Service, @Repository 등 @Component가 들어있다


### 13. 로그인, 로그아웃을 쿠키를 통해 처리
```java
@AllArgsConstructor
@Getter
public class RsData {
  private final String resultCode; // final 붙으면
  private final String msg; // 생성자 메서드 필수
  private final Object data; // 성공실패 여부 + 로그인 데이터도 보내주기 위해

  // 데이터를 두 개 받으면 실행하여 아래 오버로딩한 코드로 토스
  public static RsData of(String resultCode, String msg) {
    return new RsData(resultCode, msg, null); // 생성자 메서드 필요
  }
  // 메서드 오버로딩
  public static RsData of(String resultCode, String msg, Object data) {
    return new RsData(resultCode, msg, data);
  }
  public boolean isSuccess() {
    return resultCode.startsWith("S-"); // startsWith("S-"): S-로 시작하면
  }
}
```

```java
@Controller
@AllArgsConstructor
public class MemberController {
  private final MemberService memberService;

  @GetMapping("/member/login")
  @ResponseBody
  public RsData login(String username, String password, HttpServletResponse resp) {
    if (username == null || username.trim().isEmpty()) {
      return RsData.of("F-3", "username(을)를 입력해주세요.");
    }
    if (password == null || password.trim().isEmpty()) {
      return RsData.of("F-4", "password(을)를 입력해주세요.");
    }
    RsData rsData = memberService.tryLogin(username, password);
    if (rsData.isSuccess()) { // S-로 시작하면 쿠키를 발행하도록. 쿠키 발행에는 HttpServletResponse resp 필요
      long memberId = (long) rsData.getData(); // data는 Object이므로 형변환
      resp.addCookie(new Cookie("loginedMemberId", memberId + ""));
    }
    return rsData;
  }
  @GetMapping("/member/logout")
  @ResponseBody
  public RsData logout(HttpServletRequest req, HttpServletResponse resp) {
    if (req.getCookies() != null) { // null이면 로그인이 안 되어 있는 것
      Arrays.stream(req.getCookies())
          .filter(cookie -> cookie.getName().equals("loginedMemberId")) // 쿠키 이름이 loginedMemberId인 것을 가져와서
          .forEach(cookie -> {
            cookie.setMaxAge(0); // 쿠키 수명을 0으로 = 쿠키 만료
            resp.addCookie(cookie); // 만료된 쿠키를 보내줌
          });
    }
    return RsData.of("S-1", "로그아웃 되었습니다.");
  }
  // 마이페이지 구현
  @GetMapping("/member/me")
  @ResponseBody
  public RsData showMe(HttpServletRequest req) {
    long loginedMemberId = 0;
    if (req.getCookies() != null) { // null이면 로그인이 안 되어 있는 것
      loginedMemberId = Arrays.stream(req.getCookies())
          .filter(cookie -> cookie.getName().equals("loginedMemberId")) // 쿠키 이름이 loginedMemberId인 것을 가져와서
          .map(Cookie::getValue) // .map(cookie -> cookie.getValue) 동일. cookie에서 값을 꺼내고
          .mapToLong(Long::parseLong) // 형변환
          .findFirst() // 그 중에서 첫 번째 가져와라
          .orElse(0);
    }
    boolean isLogined = loginedMemberId > 0;
    if(!isLogined) {
      return RsData.of("F-1", "로그인 후 이용해주세요.");
    }
    Member member = memberService.findById(loginedMemberId);
    return RsData.of("S-1", "당신의 username(은)는 %s 입니다.".formatted(member.getUsername()));
  }
}
```

```java
@Repository
public class MemberRepository {
  List<Member> members;
  public MemberRepository() {
    members = new ArrayList<>();
    // 테스트데이터 생성
    members.add(new Member("user1", "1234"));
    members.add(new Member("user2", "1234"));
    members.add(new Member("user3", "1234"));
    members.add(new Member("user4", "1234"));
    members.add(new Member("user5", "1234"));
  }
  public Member findByUserName(String username) {
    return members.stream()
        .filter(member -> member.getUsername().equals(username))
        .findFirst()
        .orElse(null);
  }
  public Member findById(long id) {
    return members.stream() // 있으면 가져오고 없으면 null
        .filter(member -> member.getId() == id)
        .findFirst()
        .orElse(null);
  }
}
```

```java
@Service
public class MemberService {
  public MemberRepository memberRepository;
  public MemberService() {
    memberRepository = new MemberRepository();
  }
  public RsData tryLogin(String username, String password) {
    // 서비스 입장에서 리포지터리에 username 주면 찾아서 서비스로 보내줘
    Member member = memberRepository.findByUserName(username);
    if (member == null) {
      return RsData.of("F-2", "%s(은)는 존재하지 않는 회원입니다.".formatted(username));
    }
    if(!member.getPassword().equals(password)){
      return RsData.of("F-1", "비밀번호가 일치하지 않습니다");
    }
    // 전에는 resultCode, msg만 넘겼는데 수정하여 member.getId()를 같이 넘기고 있다
    return RsData.of("S-1", "%s님 환영합니다.".formatted(username), member.getId());
  }
  public Member findByUserName(String username) {
    return memberRepository.findByUserName(username); // 리포지터리에 username 달라고 요청
  }
  public Member findById(long id) {
    return memberRepository.findById(id); // 리포지터리에 id 달라고 요청
  }
}
```

**로그인 처리과정**
1. 프로그램 실행
2. HomeController 객체가 제일 먼저 만들어진다
- @Controller로 인해 Ioc컨테이너가 생성해준다
    - MemberService 객체 생성
        - MemberRepository 객체 생성
3. MemberController 객체 생성(이미 HomeController에 의해 MemberService, MemberRepository가 만들어져서 다시 만들어지지 않고 주소값만 공유하게 됨)
4. 고객이 /member/login?username=user1&password=1234 요청
5. MemberController::login 메서드 실행
- memberService::tryLogin 메서드 실행
    - memberRepository::findByUserName 메서드 실행
    - memberRepository::findByUserName 메서드 응답
- memberService::tryLogin 메서드 응답
6. MemberController::login 메서드 응답
7. 응답이 브라우저로 전송

**쿠키 이용해서 로그인 상태 구현**
[브라우저1] [브라우저2] <-> SBB
서버는 브라우저를 기억하지 못 한다
로그인의 표시를 남겨야함
/member/login 해서 브라우저에서 쿠키 확인해보면 loginedMemberId의 값이 잘 발행된 것을 확인 가능


### 14. Rq 도입 쿠키 처리

```java
@RequestScope // 이 객체는 매 요청마다 생성됨
@AllArgsConstructor
public class Rq {
  private final HttpServletRequest req;
  private final HttpServletResponse resp;

  // setCookie를 두 개 만드는 이유: 쿠키값이 문자열/정수 둘다 들어올 수 있기 때문
  public void setCookie(String name, long value) {
    setCookie(name, value+""); // id값이 long타입이면 실행됨
  }

  public void setCookie(String name, String value) {
    resp.addCookie(new Cookie(name, value));
  }

  public boolean removeCookie(String name) {
    Cookie cookie = Arrays.stream(req.getCookies())
        .filter(c -> c.getName().equals(name)) // 쿠키 이름이 같은 것을 가져와서
        .findFirst() // 찾았으면 cookie 객체와 연결이 되고
        .orElse(null);
    if (cookie != null) {
      cookie.setMaxAge(0); // 쿠키 만료 시킴
      resp.addCookie(cookie);
      return true; // 처리 했으면 true 넘겨줌
      }
    return false;
  }

  public long getCookieAsLong(String name, long defaultValue) {
    String value = getCookie(name, null);

    // 안 들어옴
    if(value == null) return defaultValue;

    // value값이 일치하지 않을 수 있기 때문에 try-catch로 감싸줌
    try {
      return Long.parseLong(value);
    } catch (NumberFormatException e) {
      return defaultValue;
      }
    }

  private String getCookie(String name, String defaultValue) {
    if(req.getCookies() == null) return defaultValue;

    return Arrays.stream(req.getCookies())
        .filter(cookie -> cookie.getName().equals(name)) // 쿠키 이름이 loginedMemberId인 것을 가져와서
        .map(Cookie::getValue) // .map(cookie -> cookie.getValue) 동일. cookie에서 값을 꺼내고
        .findFirst() // 그 중에서 첫 번째 가져와라
        .orElse(defaultValue);
  }
}
```

```java
@AllArgsConstructor
@Getter
public class RsData {
  private final String resultCode;
  private final String msg; 
  private final Object data;

  public static RsData of(String resultCode, String msg) {
    return new RsData(resultCode, msg, null);
  }
  // 메서드 오버로딩
  public static RsData of(String resultCode, String msg, Object data) {
    return new RsData(resultCode, msg, data);
  }
  public boolean isSuccess() {
    return resultCode.startsWith("S-"); // startsWith("S-"): S-로 시작하면
  }
  // Jackson 규칙 is~메서드 -> 출력 결과가 is 없이 Fail로 나옴
  public boolean isFail() {
    return resultCode.startsWith("F-"); // startsWith("F-"): S-로 시작하면
  }
}
```

```java
@Controller
@AllArgsConstructor
public class MemberController {
  private final MemberService memberService;
  private final Rq rq; // Rq rq = new Rq(req, resp); 를 지우고도 사용하는 방법

  @GetMapping("/member/login")
  @ResponseBody
  public RsData login(String username, String password) {
    if(username == null || username.trim().isEmpty()){
      return RsData.of("F-3", "username(을)를 입력해주세요.");
    }

    if(password == null || password.trim().isEmpty()){
      return RsData.of("F-4", "password(을)를 입력해주세요.");
    }

    RsData rsData = memberService.tryLogin(username, password);

    if (rsData.isSuccess()) {
      Member member = (Member) rsData.getData();
      // long memberId = (long) rsData.getData(); // data는 Object이므로 형변환
      // resp.addCookie(new Cookie("loginedMemberId", memberId + "")); // 쿠키 발행
      rq.setCookie("loginedMemberId", member.getId());
    }
    if (rsData.isFail()) {
      return RsData.of("F-5", "실패 테스트");
    }
    return rsData;
    }
  @GetMapping("/member/logout")
  @ResponseBody
  public RsData logout() {
    // 제거가 되면 true
    boolean cookieRemoved = rq.removeCookie("loginedMemberId");
    if(!cookieRemoved){
      return RsData.of("F-1", "이미 로그아웃 상태입니다.");
    }
    return RsData.of("S-1", "로그아웃 되었습니다.");
  }

  @GetMapping("/member/me")
  @ResponseBody
  public RsData showMe() {
    // loginedMemberId를 가져와야 됨
    // "loginedMemberId"를 주면 가져오고 없으면 defaultValue 0
    long loginedMemberId = rq.getCookieAsLong("loginedMemberId", 0);
    boolean isLogined = loginedMemberId > 0;
    if(!isLogined) {
      return RsData.of("F-1", "로그인 후 이용해주세요.");
    }
    Member member = memberService.findById(loginedMemberId);
    return RsData.of("S-1", "당신의 username(은)는 %s 입니다.".formatted(member.getUsername()));
  }
}    
```

```java
@Service
public class MemberService {
  public MemberRepository memberRepository;

  public MemberService() {
    memberRepository = new MemberRepository();
  }
  public RsData tryLogin(String username, String password) {
    Member member = memberRepository.findByUserName(username);

    if (member == null) {
      return RsData.of("F-2", "%s(은)는 존재하지 않는 회원입니다.".formatted(username));
    }
    if(!member.getPassword().equals(password)){
      return RsData.of("F-1", "비밀번호가 일치하지 않습니다");
    }
    if (!password.equals("1234")) {
    }
    else if(!username.equals("user1")){
    }
    return RsData.of("S-1", "%s님 환영합니다.".formatted(username), member); // rq도입으로 member.getId() -> mebmer
  }
  public Member findByUserName(String username) {
    return memberRepository.findByUserName(username); // 리포지터리에 username 달라고 요청
  }
  public Member findById(long id) {
    return memberRepository.findById(id); // 리포지터리에 id 달라고 요청
  }  
}
```

현재 memberController를 보면 Rq를 메서드마다 만들어주고 있음
만들 때마다 매개변수 req, resp 넘겨주는 행위 반복됨
req, resp 매개변수 안 쓰는 법을 알아보자

스프링부트에는 내부적으로 IoC컨테이너(거대한 공용상자)를 가진다
- 싱글톤패턴으로 @Controller 안에 @Component
- @Component가 붙은 것들은 IoC컨테이너가 관리하기 때문에
- IoC컨테이너가 내부적으로 프로그램 실행하자마자 객체 생성해줌
- MemberController 클래스에서 final 키워드가 붙은 memberService를 내부적으로 알아서 만들어주고 있음
- **생성자 주입**
    - public class MemberController {
      private final MemberService memberService; // 생성자 주입 시 final 필수

      @AllArgsConstructor을 사용하면 생성자주입도 생략 가능
      생성자 주입: 생상자를 만들어두고 생성자를 주입시키고 있음
      생성자 주입의 경우 @Autowired 생략 가능
      public MemberController(MemberService memberService) {
      만들어진 멤버서비스를 연결만 시켜주면 됨. 만드는 것은 Ioc컨테이너에 의해.
      this.memberService = memberService;
      }
- **필드 주입**
    - @Autowired private MemberService memberService;

- **빈**: 스프링부트 IoC컨테이너에 의해 관리되는 모든 객체(HomeController, MemberController, MemberService, MemberRepository, Rq)
    - 빈의 생성 -> 싱글톤: 프로그램 실행 시 객체가 생성
        - HomeController에서 MemberService를 쓰고 싶음. MemberRepository도 같이 생성됨
        - MemberController에서는 이미 MemberService를 쓰고 있었고 MemberRepository도 같이 생성되었음
        - 중복 생성으로 메모리가 불필요하게 사용됨

- Rq에 @Component가 붙으면 IoC컨테이너에 의해 관리
    - 프로그램 실행 시 객체가 생성됨
    - 단일스레드에서는 문제가 없지만 멀티스레드의 경우
        - @RequestScope를 같이 붙여줘야 함
        - 독립적인 객체로 사용할 수 있게 해줌

- Rq 객체를 매번 만드는 수고를 스프링에게 맡김
  - @RequestScope를 이용해서 Rq의 생명주기를 변경한다

- Rq에서 @RequestScope 한 것과 다른 클래스에서 안 붙인 것의 차이?
    - MemberController에서 MemberService를 만드는 것은 딱 한 번만 만들어짐
    - Rq에다 @RequestScope를 붙이면 메서드가 생성될 때 Rq객체가 생성됨
        - 즉, Rq를 사용하는 곳에서 Rq객체를 쓸 때만 생성되고 메서드 끝나면 같이 소멸

- IoC컨테이너에 의해 생성되는 객체(빈) vs. @RequestScope에 의해 관리되는 객체
    - 생성 주기가 다르다!
        - MemberService는 앱 시작시 생성, 앱 종료시 소멸
        - Rq는 메서드에 의해 HTTP(/member/login과 같은) 요청시 생성, 메서드가 종료되는 소멸

- 서버 실행하면 IoC컨테이너에 의해 생성되는 객체들이 메모리에 만들어짐
- Rq의 경우 프록시 객체(대리 객체)를 사용하여 프록시 객체가 대신해서 Rq객체에 연결해줌
    - HTTP요청이 들어오면 서버는 요청을 가로채서 프록시가 가로채서 @RequestScope가 붙어있는 클래스에 프록시 객체를 할당
        - IoC컨테이너에 관리되는 객체 대신에 프록시 객체를 Rq에 주입시킴
            - 프록시는 HTTP요청을 받아서 Rq객체가 있는지 없는지 확인 후 없으면 Rq를 만들어준다

- IoC컨테이너에 의해 생성되는 객체(빈): new 객체 생성할 필요 없음

- 객체를 문장화(JSON)으로 바꾸는 것은 Jackson
자바 객체 -> Jackson -> 브라우저
Jackson이 가지고 있는 규칙
- **is~ 메서드**: 매개변수 받지 않는 메서드 실행시 그 결과가 화면에 return됨
- **get~ 메서드**: getAbc 메서드라고 한다면 get 제외 Abc를 리턴해줌

### 15. 세션

서버 -> 클라이언트(쿠키발행)
1. 서버는 브라우저를 기억(구분)하지 못 한다 -> 쿠키 도입
2. 쿠키는 수정(조작)이 가능하다는 단점
3. 세션(저장소)을 도입

브라우저 -> 서버 최초 접속 시 쿠키 발행(A1)
A1(발행한 쿠키의 세션 ID)을 세션에도 저장
세션ID는 16진수로 알아볼 수 없게 발행(보안을 위해)

**세션과 쿠키의 차이**
- 쿠키는 클라이언트와 서버에서 값을 생성/수정/삭제할 수 있다.
- 세션은 서버에서만 값을 생성/수정/삭제할 수 있다.
- 쿠키는 클라이언트에서 값을 조작할 수 있기 때문에, 보안에 취약하다.
- 서버는 클라이언트에서 값을 조작할 수 없기 때문에, 보안성이 좋다.
- 각 브라우저 별로 유지해야하는 중요한 정보는 세션에 저장하는게 좋다.
- 예를들어 현재 접속한 브라우저가 몇번 회원인지에 대한 정보가 중요한 정보이다.
- 각 브라우저 별로 유지해야하는 별로 중요하지 않은 정보는 쿠키에 저장해도 된다.
- JSESSIONID 는 중요한 정보이지만 구조상 어쩔 수 없이 쿠키에 저장되어야 한다.
- JSESSIONID 는 클라이언트(브라우저)가 조작을 하더라도 본인만 손해이기 때문에, 보통은 조작을 하지 않는다.

JSESSIONID: 자바 세션 아이디
- value는 노출되어선 안 된다!

로그인 상태를 유지하기 위해 각 브라우저 별로 loginedMemberId를 쿠키로 보관하는 대신, 세션에 저장

```java
@Component
@RequestScope
@AllArgsConstructor
public class Rq {
  private final HttpServletRequest req;
  private final HttpServletResponse resp;

  public void setCookie(String name, long value) {
    setCookie(name, value+""); // id값이 long타입이면 실행됨
  }

  public void setCookie(String name, String value) {
    resp.addCookie(new Cookie(name, value));
  }

  public boolean removeCookie(String name) {
    Cookie cookie = Arrays.stream(req.getCookies())
        .filter(c -> c.getName().equals(name)) // 쿠키 이름이 같은 것을 가져와서
        .findFirst() // 찾았으면 cookie 객체와 연결이 되고
        .orElse(null);

    if (cookie != null) {
      cookie.setMaxAge(0); // 쿠키 만료 시킴
      resp.addCookie(cookie);

      return true; // 처리 했으면 true 넘겨줌
    }
    return false;
  }

  public long getCookieAsLong(String name, long defaultValue) {
    String value = getCookie(name, null);

    // 안 들어옴
    if(value == null) return defaultValue;

    // value값이 일치하지 않을 수 있기 때문에 try-catch로 감싸줌
    try {
      return Long.parseLong(value);
    } catch (NumberFormatException e) {
      return defaultValue;
    }
  }

  private String getCookie(String name, String defaultValue) {
    if(req.getCookies() == null) return defaultValue;

    return Arrays.stream(req.getCookies())
        .filter(cookie -> cookie.getName().equals(name)) // 쿠키 이름이 loginedMemberId인 것을 가져와서
        .map(Cookie::getValue) // .map(cookie -> cookie.getValue) 동일. cookie에서 값을 꺼내고
        .findFirst() // 그 중에서 첫 번째 가져와라
        .orElse(defaultValue);
  }
  private String getSessionAsStr(String name, String defaultValue) {
    try {
      //  session에서 name을 가져와서 문자화
      String value = (String) req.getSession().getAttribute(name); // name으로 접근한 session 데이터 가져옴
      // 형변환 하는 이유는 getAttribute 값이 Object 이기 때문
      if(value == null) return defaultValue;
      return value;
    } catch (Exception e) {
      return defaultValue;
    }
  }
  public long getSessionAsLong(String name, long defaultValue) {
    try {
      long value = (long) req.getSession().getAttribute(name);
      return value;
    } catch (Exception e) {
      return defaultValue;
    }
  }
  public void setSession(String name, long value) {
    HttpSession session = req.getSession();
    session.setAttribute(name, value);
  }
  public boolean removeSession(String name) {
    // session 객체를 가져오기 위해 외워야 함
    HttpSession session = req.getSession();
    // 세션을 가져왔는데 없으면 삭제를 못 했다는 의미
    if(session.getAttribute(name) == null) return false; // name은 로그인 id.
    session.removeAttribute(name);
    return true;
  }
}
```

```java
@Controller
@AllArgsConstructor
public class MemberController {
  private final MemberService memberService; // 생성자 주입 시 final 필수
  private final Rq rq; // Rq rq = new Rq(req, resp); 를 지우고도 사용하는 방법
  @GetMapping("/member/login")
  @ResponseBody
  public RsData login(String username, String password) {
    if(username == null || username.trim().isEmpty()){
      return RsData.of("F-3", "username(을)를 입력해주세요.");
    }
    if(password == null || password.trim().isEmpty()){
      return RsData.of("F-4", "password(을)를 입력해주세요.");
    }
    RsData rsData = memberService.tryLogin(username, password);
    if (rsData.isSuccess()) { // S-로 시작하면 쿠키를 발행하도록. 쿠키 발행에는 HttpServletResponse resp 필요
      Member member = (Member) rsData.getData();
      rq.setSession("loginedMemberId", member.getId());
    }
    if (rsData.isFail()) {
      return RsData.of("F-5", "실패 테스트");
    }
    return rsData;
  }

  @GetMapping("/member/logout")
  @ResponseBody
  public RsData logout() {
    // removeCookie 대신 removeSession
    boolean cookieRemoved = rq.removeSession("loginedMemberId");
    if(!cookieRemoved) {
      return RsData.of("F-1", "이미 로그아웃 상태입니다.");
    }
    return RsData.of("S-1", "로그아웃 되었습니다.");
  }

  // 마이페이지 구현
  @GetMapping("/member/me")
  @ResponseBody
  public RsData showMe() {
    long loginedMemberId = rq.getSessionAsLong("loginedMemberId", 0);
    boolean isLogined = loginedMemberId > 0;
    if(!isLogined) {
      return RsData.of("F-1", "로그인 후 이용해주세요.");
    }
    Member member = memberService.findById(loginedMemberId);
    return RsData.of("S-1", "당신의 username(은)는 %s 입니다.".formatted(member.getUsername()));
  }
}
```

### 16. 로그인 폼 구현하기

form 보여주는 역할(로그인 폼)
form 처리하는 역할(로그인 폼 처리)

로그인 할 때 아이디, 패스워드를 파라미터로 넘기지 않는다
form을 활용해서 로그인 아이디, 패스워드 값을 넘겨줌
form을 통해 복잡한 URL을 쉽게 생성할 수 있다.
<ul>
	<li>action=받는사람</li>
	<li>method=배송방법</li>
	<li>폼안의요소=편지내용</li>
</ul>
<h1>네이버 검색</h1>
<!-- method="GET" 생략 가능 -->
<!-- target="_blank" 새창 열기 -->
<form method="GET" action="https://search.naver.com/search.naver" target="_blank">
	<input type="text" name="query" value="사과" placeholder="검색어">
	<!-- 	<input type="submit" value="버튼"> -->
	<button type="submit">버튼</button>
</form>
<h1>tutorial1 로그인</h1>
<form method="GET" action="http://localhost:8080/member/login" target="_blank">
	<input type="text" name="username" placeholder="아이디">
	<input type="password" name="password" placeholder="비밀번호">
	<button type="submit">로그인</button>
</form>

```java
@Component
@RequestScope
@AllArgsConstructor
public class Rq {
  private final HttpServletRequest req;
  private final HttpServletResponse resp;

  public void setCookie(String name, long value) {
    setCookie(name, value+""); // id값이 long타입이면 실행됨
  }

  public void setCookie(String name, String value) {
    resp.addCookie(new Cookie(name, value));
  }

  public boolean removeCookie(String name) {
    Cookie cookie = Arrays.stream(req.getCookies())
        .filter(c -> c.getName().equals(name)) // 쿠키 이름이 같은 것을 가져와서
        .findFirst() // 찾았으면 cookie 객체와 연결이 되고
        .orElse(null);

    if (cookie != null) {
      cookie.setMaxAge(0); // 쿠키 만료 시킴
      resp.addCookie(cookie);

      return true; // 처리 했으면 true 넘겨줌
    }
    return false;
  }

  public long getCookieAsLong(String name, long defaultValue) {
    String value = getCookie(name, null);

    // 안 들어옴
    if(value == null) return defaultValue;

    // value값이 일치하지 않을 수 있기 때문에 try-catch로 감싸줌
    try {
      return Long.parseLong(value);
    } catch (NumberFormatException e) {
      return defaultValue;
    }
  }

  private String getCookie(String name, String defaultValue) {
    if(req.getCookies() == null) return defaultValue;

    return Arrays.stream(req.getCookies())
        .filter(cookie -> cookie.getName().equals(name)) // 쿠키 이름이 loginedMemberId인 것을 가져와서
        .map(Cookie::getValue) // .map(cookie -> cookie.getValue) 동일. cookie에서 값을 꺼내고
        .findFirst() // 그 중에서 첫 번째 가져와라
        .orElse(defaultValue);
  }
  private String getSessionAsStr(String name, String defaultValue) {
    try {
      //  session에서 name을 가져와서 문자화
      String value = (String) req.getSession().getAttribute(name); // name으로 접근한 session 데이터 가져옴
      // 형변환 하는 이유는 getAttribute 값이 Object 이기 때문
      if(value == null) return defaultValue;
      return value;
    } catch (Exception e) {
      return defaultValue;
    }
  }
  public long getSessionAsLong(String name, long defaultValue) {
    try {
      long value = (long) req.getSession().getAttribute(name);
      return value;
    } catch (Exception e) {
      return defaultValue;
    }
  }
  public void setSession(String name, long value) {
    HttpSession session = req.getSession();
    session.setAttribute(name, value);
  }
  public boolean removeSession(String name) {
    // session 객체를 가져오기 위해 외워야 함
    HttpSession session = req.getSession();
    // 세션을 가져왔는데 없으면 삭제를 못 했다는 의미
    if(session.getAttribute(name) == null) return false; // name은 로그인 id.
    session.removeAttribute(name);
    return true;
  }
  // 로그인이 되었는지 확인
  public boolean isLogined() {
    // 세션에서 loginedMemberId으로 된 것이 있는지 확인
    long loginedMemberId = getSessionAsLong("loginedMemberId", 0);
    return loginedMemberId > 0;
  }
  public boolean isLogout() {
    return !isLogined();
  }
}
```

```java
@Controller
@AllArgsConstructor
public class MemberController {
  private final MemberService memberService; // 생성자 주입 시 final 필수
  private final Rq rq; // Rq rq = new Rq(req, resp); 를 지우고도 사용하는 방법
  @GetMapping("/member/login")
  @ResponseBody
  public String showLogin() {
    // 중복 로그인 방지
    if(rq.isLogined()) {
      return """
          <h1>이미 로그인 되어있습니다.</h1>
          """.stripIndent();
    }
    return """
        <h1>로그인</h1>
        <form action="/member/doLogin">
         <input type="text" name="username" placeholder="아이디" />
         <input type="password" name="password" placeholder="비밀번호" />
         <button type="submit">로그인</button>
        </form>
        """;
  }
  @GetMapping("/member/doLogin")
  @ResponseBody
  public RsData login(String username, String password) {
    if(username == null || username.trim().isEmpty()){
      return RsData.of("F-3", "username(을)를 입력해주세요.");
    }
    if(password == null || password.trim().isEmpty()){
      return RsData.of("F-4", "password(을)를 입력해주세요.");
    }
    RsData rsData = memberService.tryLogin(username, password);
    if (rsData.isSuccess()) { // S-로 시작하면 쿠키를 발행하도록. 쿠키 발행에는 HttpServletResponse resp 필요
      Member member = (Member) rsData.getData();
      rq.setSession("loginedMemberId", member.getId());
    }
    if (rsData.isFail()) {
      return RsData.of("F-5", "실패 테스트");
    }
    return rsData;
  }

  @GetMapping("/member/logout")
  @ResponseBody
  public RsData logout() {
    // removeCookie 대신 removeSession
    boolean cookieRemoved = rq.removeSession("loginedMemberId");
    if(!cookieRemoved) {
      return RsData.of("F-1", "이미 로그아웃 상태입니다.");
    }
    return RsData.of("S-1", "로그아웃 되었습니다.");
  }

  // 마이페이지 구현
  @GetMapping("/member/me")
  @ResponseBody
  public RsData showMe() {
    long loginedMemberId = rq.getSessionAsLong("loginedMemberId", 0);
    boolean isLogined = loginedMemberId > 0;
    if(!isLogined) {
      return RsData.of("F-1", "로그인 후 이용해주세요.");
    }
    Member member = memberService.findById(loginedMemberId);
    return RsData.of("S-1", "당신의 username(은)는 %s 입니다.".formatted(member.getUsername()));
  }
}
```

### 17. login.html 반영

build.gradle dependencies에 implementation 'org.springframework.boot:spring-boot-starter-thymeleaf' 추가

- /member/doLogin -> 절대경로
- /../doLogin -> 상대경로
- form의 action=doLogin만 해도 됨

타임리프는 templates를 기준으로 읽는다
- usr
    - member
        - login

아래 코드 위치 resources/main/static/index.html
```html
<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>메인 페이지</title>
</head>
<body>
<h1>스프링부트 메인페이지</h1>
</body>
</html>
```

아래 코드 위치 resources/main/templates/usr/member/login.html
```html
<h1>로그인 페이지</h1>
<form method="GET" action="doLogin">
    <input type="text" name="username" placeholder="아이디" />
    <input type="password" name="password" placeholder="비밀번호" />
    <button type="submit">로그인</button>
</form>
```

```java
@Controller
@AllArgsConstructor
public class MemberController {
  private final MemberService memberService; // 생성자 주입 시 final 필수
  private final Rq rq; // Rq rq = new Rq(req, resp); 를 지우고도 사용하는 방법
  @GetMapping("/member/login")
  // @ResponseBody: return값을 화면에 보여주기 때문에 페이지 경로 이동을 위해 지워줌
  public String showLogin() {
    "usr/member/login"; // templates 안에 있어야 함
  }
  @GetMapping("/member/doLogin")
  @ResponseBody
  public RsData login(String username, String password) {
    if(username == null || username.trim().isEmpty()){
      return RsData.of("F-3", "username(을)를 입력해주세요.");
    }
    if(password == null || password.trim().isEmpty()){
      return RsData.of("F-4", "password(을)를 입력해주세요.");
    }
    RsData rsData = memberService.tryLogin(username, password);
    if (rsData.isSuccess()) { // S-로 시작하면 쿠키를 발행하도록. 쿠키 발행에는 HttpServletResponse resp 필요
      Member member = (Member) rsData.getData();
      rq.setSession("loginedMemberId", member.getId());
    }
    if (rsData.isFail()) {
      return RsData.of("F-5", "실패 테스트");
    }
    return rsData;
  }

  @GetMapping("/member/logout")
  @ResponseBody
  public RsData logout() {
    // removeCookie 대신 removeSession
    boolean cookieRemoved = rq.removeSession("loginedMemberId");
    if(!cookieRemoved) {
      return RsData.of("F-1", "이미 로그아웃 상태입니다.");
    }
    return RsData.of("S-1", "로그아웃 되었습니다.");
  }

  // 마이페이지 구현
  @GetMapping("/member/me")
  @ResponseBody
  public RsData showMe() {
    long loginedMemberId = rq.getSessionAsLong("loginedMemberId", 0);
    boolean isLogined = loginedMemberId > 0;
    if(!isLogined) {
      return RsData.of("F-1", "로그인 후 이용해주세요.");
    }
    Member member = memberService.findById(loginedMemberId);
    return RsData.of("S-1", "당신의 username(은)는 %s 입니다.".formatted(member.getUsername()));
  }
}
```

### 18. 로그인 POST 방식으로 처리

로그인 요청을 보내면 브라우저가 GET방식으로 받는다
- @GetMapping을 통해 GET으로 받으라고 명시했음
- RequestMethod가 GET 방식

GET과 POST
- GET: 폼 노출
- POST : 폼 처리
  http://localhost:8080/member/doLogin?username=user1&password=1234
- url은 노출되어서는 안 된다
- 노출되는 이유는 url처리를 GET방식으로 했기 때문
  -> POST 방식으로 처리하면 어떻게 되는가?
  http://localhost:8080/member/doLogin
- 중요한 파라미터가 노출되지 않고 암호화되어 넘어감
- 데이터 생성, 추가, 삭제 시에는 POST!

```html
<h1>로그인 페이지</h1>
<form method="POST" action="doLogin">
    <input type="text" name="username" placeholder="아이디" />
    <input type="password" name="password" placeholder="비밀번호" />
    <button type="submit">로그인</button>
</form>
```

```java
@Controller
@AllArgsConstructor
public class MemberController {
  private final MemberService memberService; // 생성자 주입 시 final 필수
  private final Rq rq; // Rq rq = new Rq(req, resp); 를 지우고도 사용하는 방법

  @GetMapping("/member/login")
  // @ResponseBody: return값을 화면에 보여주기 때문에 페이지 경로 이동을 위해 지워줌
  public String showLogin() {
    "usr/member/login"; // templates 안에 있어야 함
  }

  @PostMapping("/member/doLogin") // GET -> POST 변경
  @ResponseBody
  public RsData login(String username, String password) {
    if (username == null || username.trim().isEmpty()) {
      return RsData.of("F-3", "username(을)를 입력해주세요.");
    }
    if (password == null || password.trim().isEmpty()) {
      return RsData.of("F-4", "password(을)를 입력해주세요.");
    }
    RsData rsData = memberService.tryLogin(username, password);
    if (rsData.isSuccess()) { // S-로 시작하면 쿠키를 발행하도록. 쿠키 발행에는 HttpServletResponse resp 필요
      Member member = (Member) rsData.getData();
      rq.setSession("loginedMemberId", member.getId());
    }
    if (rsData.isFail()) {
      return RsData.of("F-5", "실패 테스트");
    }
    return rsData;
  }
  // 생략
}
```

### 19. me.html 그리고 th:if 타임리프 문법 도입하여 랜더링

JSP 수업에서 모델2 방식 배웠을 때
- 서블릿 : 데이터 발송
- JSP : 서브릿 단에서 발송된 데이터를 받는다
  스프링부트도 모델2 방식이 그대로 적용되어 있다!
- 컨트롤러 단에서 프론트로 데이터를 발송
- html에서 컨트롤러에서 보내온 데이터를 화면에 뿌리는 게 가능
  스프링부트에서는
  HttpServletRequest req ${member.username} 이 아닌
  -> Model model [[${member.id}]]을 이용


아래 코드 위치 resources/main/templates/usr/member/me.html
```html
<div th:if="${member != null}">
    <h1>내 정보</h1>
    <h2>회원번호 : [[${member.id}]]</h2>
    <h2>아이디 : [[${member.username}]]</h2>
</div>
<div th:if="${member == null}">
    <h1>로그인 후 이용해주세요.</h1>
</div>
```

```java
@Component
@RequestScope
@AllArgsConstructor
public class Rq {
  private final HttpServletRequest req;
  private final HttpServletResponse resp;
  // 중간 코드 생략
  public long getLoginedMember() {
    return getSessionAsLong("loginedMemberId", 0); // member를 가져오기 위함
  }
}
```

```java
@Controller
@AllArgsConstructor
public class MemberController {
  private final MemberService memberService; // 생성자 주입 시 final 필수
  private final Rq rq; // Rq rq = new Rq(req, resp); 를 지우고도 사용하는 방법
  // 중간 코드생략

  @GetMapping("/member/me")
  public String showMe(Model model) {
    long loginedMemberId = rq.getLoginedMember(); // 로그인된 회원의 세션 정보를 loginedMemberId에 담고
    Member member = memberService.findById(loginedMemberId); // loginedMemberId id를 주게 되면 찾아서 member에 주소값 넣어줌
    model.addAttribute("member", member); // 속성 이름, 속성 값
    return "usr/member/me";
  }
}
```

### 20. DB 생성 및 연결

build.gradle, application.yml 파일을 설정해야 DB 접속 가능!

현재 member 데이터를 Repository의 List에 저장하고 있음
- 프로그램 실행 시 만들어지고 종료시 소멸 = 메모리(RAM)에 저장
- DB를 사용해야 데이터를 영속성있게 저장 가능
- 게시물 작성, 댓글, 사용자 정보 등 DB에 저장

```sql
# DB 삭제, 생성, 선택
DROP DATABASE IF EXISTS tutorial1__dev;
CREATE DATABASE tutorial1__dev;
USE tutorial1__dev;
```
tutorial1/build.gradle dependencies에 아래 코드 추가
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'

build/resources/main/application.yml에 아래 코드 도입
```yml
spring:  
  output:
    ansi:
      enabled: always # 콘솔 색상 변경
  thymeleaf:
    cache: false # 타임리프 캐시 끄기
    prefix: file:src/main/resources/templates/ # 타임리프 캐시 끄기(이 설정을 해야 꺼짐)
    devtools:
      livereload:
        enabled: true
      restart:
        enabled: true
  datasource:
    url: jdbc:mariadb://127.0.0.1:3306/tutorial1__dev?useUnicode=true&characterEncoding=utf8&autoReconnect=true&serverTimezone=Asia/Seoul
    username: sbsst
    password: sbs123414
    driver-class-name: org.mariadb.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: create # 옵션: none, validate, update, create, create-drop
    show-sql: true       # SQL 쿼리를 출력 여부
    properties:
      hibernate:
        show_sql: true # 실행되는 SQL 쿼리 확인
        format_sql: true # 출력되는 SQL을 포맷팅
        use_sql_comments: true # 실행되는 SQL문을 조금더 명확하게 볼 수 있도록
```

### 21. Article 클래스

Article 클래스 생성부터
- article 테이블에 id 칼럼에 AUTO INCREMENT 적용, 날짜 칼럼(create_date, modify_date) 추가
- ArticleRepository 도입, article 객체를 저장(save), 저장이 되면 결국 INSERT 쿼리가 실행된다.
-  ArticleService 도입, show_sql 설정으로 실제로 JPA에서 실행해주는 SQL을 콘솔에서 확인
- Article 클래스에 생성자들 추가
- 엔티티 객체 등록시 등록날짜 자동생성, 수정시 수정날짜 자동갱신

```java
@SpringBootApplication
@EnableJpaAuditing // @EntityListeners 기능 사용하려면 필요
public class Tutorial1Application {

  public static void main(String[] args) {
    SpringApplication.run(Tutorial1Application.class, args);
  }
}
```

```java
@Entity
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@EntityListeners(AuditingEntityListener.class) // 엔티티 변경 사항을 감지하는 리스너
public class Article {
  @Id // primary key가 id 칼럼 적용
  @GeneratedValue(strategy = IDENTITY) // AUTO_INCREMENT
  private long id;
  @CreatedDate // 생성 시 자동으로 값 설정
  @Column(updatable = false) // 업데이트 발생시 날짜가 수정되지 않도록 설정
  private LocalDateTime createDate; // 데이터 생성 날짜
  @LastModifiedDate // 수정 시 자동으로 값 갱신
  private LocalDateTime modifyDate; // 데이터 수정 날짜
  private String subject;
  private String content;
}
```

Member 클래스 위치를 dto -> entity 패키지로 이동
entity는 테이블과 1:1 맵핑되는 클래스

```java
@Controller
@RequestMapping("/article")
@RequiredArgsConstructor // 필드 중에서 final 붙은 것만 인자로 입력받는 생성자 생성. Rq 사용을 위해.
public class ArticleController {
  private final ArticleService articleService; // 서비스 객체는 스프링부트 IoC컨테이너에 의해 관리
  @GetMapping("/write")
  @ResponseBody
  public RsData write(String subject, String content) {
    // 제목과 내용 입력 안 되었을 때 유효성검사
    if(subject == null || subject.trim().isEmpty()) {
      return RsData.of("F-1", "subject(을)를 입력해주세요.");
    }
    if(content == null || content.trim().isEmpty()) {
      return RsData.of("F-2", "content(을)를 입력해주세요.");
    }
    Article createArticle = articleService.write(subject, content);
    return RsData.of("S-1", "%d번 글이 생성되었습니다.".formatted(createArticle.getId()), createArticle);  
  }
}
```

```java
// @Repository : 생략가능
// SQL 쿼리 등 JPA, DB 관련
public interface ArticleRepository extends JpaRepository<Article, Long> {
}
```

```java
@Service
@AllArgsConstructor
public class ArticleService {
  private final ArticleRepository articleRepository;
  public Article write(String subject, String content) {
    // return articleRepository.write(subject, content); 기존 JSP까지는 이런 코드였지만 스프링부트는 안씀
    Article article = Article
        .builder()
        .subject(subject)
        .content(content)
        .build();
    // JPA가 알아서 판단해서 insert/update 쿼리 실행해줌
    articleRepository.save(article); // insert 또는 update 쿼리 실행
    return article;
  }
}
```

http://localhost:8080/article/write?subject=제목1&content=내용1
위 url로 인해 아래 코드 실행됨

```sql
INSERT INTO article
SET create_date = NOW(),
modify_date = NOW(),
subject = '제목1',
content = '내용1';
```
- @Builder // 객체를 만들 때 내가 원하는 코드를 삽입할 수 있게 해줌
- JPA를 사용하려면 Entity 클래스가 무조건 필요하다
- Entity는 DB 테이블과 1:1 매칭되는 클래스(현재 Article 클래스 @Entity)
- Entity가 있으면 Repository가 반드시 있어야 한다
- 리포지터리는 인터페이스!!
- public interface ArticleRepository extends JpaRepository<Article, Long> 에서
  - <Article, Long> = <Entity, id 타입>

- @RequiredArgsConstructor // 필드 중에서 final 붙은 것만 인자로 입력받는 생성자 생성
  ```java
  public ArticleController(ArticleRepository articleRepository) {
  this.articleRepository = articleRepository;
  }
  ```
- @RequiredArgsConstructor 와 @AllArgsConstructor 차이
  - @AllArgsConstructor: 모든 생성자 메서드 만듦(인자 있는 것과 없는 것 모두)
  - @RequiredArgsConstructor: final만 취급


### 22. Spring Data JPA → 하이버네이트(JPA 구현체) → MariaDB Driver(JDBC 구현체) → MariaDB

Spring Data JPA -> 하이버네이트(JPA 구현체) -> MariaDB Driver(JDBC 구현체) -> MariaDB

- Spring Data JPA는 내부적으로 JPA를 사용하고 JPA는 내부적으로 하이버네트라는 기술이다.
- 하이버네이트 내부적으로 JDBC를 사용한다.
- JDBC는 JDBC 드라이버(MariaDB)한테 일을 시키고, 최종적으로 MariaDB가 일을 한다.

레시피, 요리사
- 라면을 만드는 방법(레시피) --> 인터페이스 --> 어떤 일을 해야 하는가?
- 레시피를 따라 라면을 실제로 만듦(요리사) --> 구현체 --> 어떻게 할지를 정의!

고객 -> 메뉴판(JPA) 주문 -> 요리사(하이버네이트) 명령 수행 -> 배달원(MariaDB 드라이버) <-통신-> 창고(DB) 데이터 처리


1. SpringData JPA : '손님1'이 메뉴를 보고 '햄버거' 주문
2. Hibernate
- 요청을 받는다.
- SELECT * FROM `member` WHERE username = '손님1'; SQL 생성
3. MariaDB Driver : SQL문을 MariaDB 한테 전달
4. MariaDB : SQL을 실행하고 결과를 전달
5. 결과는 역순으로 전달되어 JAVA 객체로 변환되서 '손님1'한테 전달


### 23. member 엔티티 도입, JPA 적용하여 회원을 영속화

위치 boundedContext.member.entity
```java
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@EntityListeners(AuditingEntityListener.class) // 엔티티 변경 사항을 감지하는 리스너
public class Member {
  @Id // primary key가 id 칼럼 적용
  @GeneratedValue(strategy = IDENTITY) // AUTO_INCREMENT
  private long id;
  @CreatedDate // 생성 시 자동으로 값 설정
  @Column(updatable = false) // 업데이트 발생시 날짜가 수정되지 않도록 설정
  private LocalDateTime createDate; // 데이터 생성 날짜
  @LastModifiedDate // 수정 시 자동으로 값 갱신
  private LocalDateTime modifyDate; // 데이터 수정 날짜
  @Column(unique = true) // unique key 부여
  private String username;
  private String password;
}
```
```java
public interface MemberRepository extends JpaRepository<Member, Long> {
  Optional<Member> findByUsername(String username);
}
```

```java
// 아래 클래스는 Ioc 컨테이너에 의해 생사소멸이 관리된다.
@Service // @Component : @Component와 같은 의미, 가독성 때문에 이렇게 표기
@AllArgsConstructor
public class MemberService {
  public final MemberRepository memberRepository;

  public RsData tryLogin(String username, String password) {
    Member member = memberRepository.findByUsername(username).orElse(null);
    // 중간 코드 생략
    return RsData.of("S-1", "%s님 환영합니다.".formatted(username), member);
  }
    public Member findByUserName (String username){
      return memberRepository.findByUsername(username).orElse(null);
    }
    public Member findById (long id){
      return memberRepository.findById(id).orElse(null);
    }
  }
```

### 24. ddl-auto 값 설명

src/main/resources/application.yml에서

ddl-auto
- create : 기존테이블 삭제 후 새로 생성
  -> 모든 데이터 삭제
  -> 테스트 환경에서 적합

- update : (재실행 되어도) 기존테이블을 유지
  -> 새로운 필드나 테이블 추가되는 경우 처리
  -> 개발환경 또는 간단한 변경사항 있을 시 사용


### 25. NotProd 도입 및 회원가입 폼 구현
- spring.jpa.hibernate.ddl-auto의 값을 create로 변경하고, 
- NotProd 도입, 
- 더 좋은 초반데이터 세팅
- 회원 가입 폼 구현 및 폼 처리

NotProd 클래스
- application.yml에 dev환경 명시해줘야 함
- NotProd : 개발환경이 아니고, 테스트 환경이 아닐 때만 실행
- @Bean // Bean 등록. Ioc컨테이너에 의해 관리되는 객체 = bean
- NotProd로 스프링부트 앱이 실행되고 본격적으로 작동하기 전에 실행되도록 세팅

```yml
spring:
  profiles:
    active: dev # 기본적으로 dev 환경임을 명시
  output:
    ansi:
      enabled: always # 콘솔 색상 변경
  thymeleaf:
    cache: false # 타임리프 캐시 끄기
    prefix: file:src/main/resources/templates/ # 타임리프 캐시 끄기(이 설정을 해야 꺼짐)
    devtools:
      livereload:
        enabled: true
      restart:
        enabled: true
  datasource:
    url: jdbc:mariadb://127.0.0.1:3306/tutorial1__dev?useUnicode=true&characterEncoding=utf8&autoReconnect=true&serverTimezone=Asia/Seoul
    username: sbsst
    password: sbs123414
    driver-class-name: org.mariadb.jdbc.Driver

  jpa:
    hibernate:
      ddl-auto: create # 옵션: none, validate, update, create, create-drop
    properties:
      hibernate:
        show_sql: true # 실행되는 SQL 쿼리 확인
        format_sql: true # 출력되는 SQL을 포맷팅
        use_sql_comments: true
```

위치 /base/initData/NotProd.java
```java
@Configuration
@Profile({"dev", "test"})
// Production(운영 환경, 라이브 서버)이 아니다.
// NotProd : 개발환경이 아니고, 테스트 환경이 아닐때만 실행
public class NotProd {
  @Bean
  CommandLineRunner initData(MemberService memberService, ArticleService articleService) {
    return args -> {
      // 이 부분은 스프링부트 앱이 실행되고, 본격적으로 작동하기 전에 실행된다.
      memberService.join("user1", "1234");
      memberService.join("user2", "1234");
      memberService.join("user3", "1234");
      memberService.join("user4", "1234");
      memberService.join("user5", "1234");

      articleService.write("제목1", "내용1");
      articleService.write("제목2", "내용2");
    };
  }
}
```

```java
@Service
@AllArgsConstructor
public class MemberService {
  public final MemberRepository memberRepository;
  // 중간 코드 생략
  public RsData join(String username, String password) {
    Member member = Member.builder()
        .username(username)
        .password(password)
        .build();
    memberRepository.save(member);
    return RsData.of("S-1", "회원 가입되었습니다.", member);
  }
}
```

위치 resources/main/templates/usr/member/join.html
```html
<h1>회원가입 페이지</h1>
<form method="POST" action="doJoin">
  <input type="text" name="username" placeholder="아이디">
  <input type="password" name="password" placeholder="비밀번호">
  <button type="submit">회원가입</button>
</form>
```

코드 중 findByUserName으로 되어 있는 코드 모두 findByUsername 이렇게 수정

```java
@AllArgsConstructor
@Controller
public class MemberController {
  private final MemberService memberService;
  private final Rq rq;

  @GetMapping("/member/join")
  public String showJoin() {
    return "usr/member/join";
  }

  @PostMapping("/member/doJoin")
  @ResponseBody
  public RsData join(String username, String password) {
    if (username == null || username.trim().isEmpty()) {
      return RsData.of("F-3", "username(을)를 입력해주세요.");
    }
    Member member = memberService.findByUsername(username);
    if (member != null) {
      return RsData.of("F-5", "%s(은)는 이미 존재하는 회원입니다.".formatted(username));
    }
    if (password == null || password.trim().isEmpty()) {
      return RsData.of("F-4", "비밀번호를 입력해주세요.");
    }
    RsData rsData = memberService.join(username, password);
    return rsData;
  }
  // 아래 코드 생략
}
```

### 끝