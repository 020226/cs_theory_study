### 자바 텍스트 게시판 구현하기

[수업자료](https://www.slog.gg/p/13829)
[수업링크](https://www.youtube.com/watch?v=PngsADCv2xk&feature=youtu.be)

---

### 0. 공부 시작 전 숙지 사항
- 내가 무엇을 할 것인지 파악해야 함
```
게시물 리스트 정렬 구현
/usr/article/list?orderBy=idDesc -> 내림차순 정렬
/usr/article/list?orderBy=idAsc -> 오름차순 정렬

0. boolean orderByIdDesc 값을 만든다.
 - boolean orderByIdDesc = true;
1. params에 orderBy 값이 있는지 체크
 - params.containsKey("orderBy")
2. orderBy가 있다면 그 값이 idAsc인지 체크
 - params.get("orderBy").equals("idAsc")
3. 참이라면 게시물 리스트를 정순으로 출력
 - orderByIdDesc = false로 변경
4. orderBy 값에 따라서 역순순회, 정순순회
```

### 1. 프로젝트 github 푸시
```
git init -- 로컬 저장소 생성
git remote add origin  "원격 저장소 주소"
git config --global user.name "계정 아이디"
git config --global user.email "계정 이메일"
git add . --> 로컬 저장소에 프로젝트 업로드
git commit -m "세팅" --> 업데이트 된 프로젝트 기록 남김
git push origin master(main) --> 원격저장소에 프로젝트 업로드
```

### 2. 게시판 시작과 종료, 기본 기능
**기본 기능**
1. exit 명령이 나올 때 까지 계속 입력받기
2. /usr/article/write 라고 입력하면 게시물 제목, 내용 입력받기
3. 생성된 게시물 정보를 Article 클래스의 객체로 저장 후 문장으로 출력
4. toString 메서드를 오버라이드 하여 Article 객체가 문장으로 출력될 때, 좀 더 설명적으로 나오도록
5. 생성자를 이용해서 게시물 객체를 쉽게 만들기
6. /usr/article/detail 이라고 입력하면, 가장 마지막에 입력받은 게시물의 상세정보 출력
7. /usr/article/list 로 입력하면 게시물리스트 출력, 시작
8. 테스트 게시물 생성 함수 적용
9. 게시물 리스트에서 출력을 최신순으로
10. 게시물 등록시, 마지막 게시물 번호 이후로 id 정하기 
11. lastArticle 변수의 필요성을 제거

src/../text_board/Main.java
```java
public class Main {
  // 8. 테스트 게시물 생성 함수 적용
  static void makeTestData(List<Article> articles) {
    // main이 static이기 때문에 호출되려면 메서드도 static이어야 함
    // static은 프로그램 실행되자마자 제일 먼저 로딩
    articles.add(new Article(1, "제목1", "내용1"));
    articles.add(new Article(2, "제목2", "내용2"));
    articles.add(new Article(3, "제목3", "내용3")); // 인덱스 번호 2, id는 3
  }
  
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    List<Article> articles = new ArrayList<>();
    makeTestData(articles); // articles에 게시물 데이터가 아니라 리스트 객체 주소값이 공유됨
    // 매개변수로 articles를 넘겨줌 -> makeTestData(List<Article> articles)
    // 매개변수로 10을 넘겨줌 makeTestData(10); -> makeTestData(int id)

    // 10. 게시물 등록시, 마지막 게시물 번호 이후로 id 정하기
    int lastArticleId = articles.get(articles.size() -1).id; // articles의 크기의 -1 값(2)의 인덱스의 id인 번호(3)를 articles에서 get 가져온다
    // int lastArticleId = 0;으로 세팅을 해줬었던 기존 코드는 테스트게시물 이후 새 게시물 작성하면 1번으로 작성됨
    // makeTestData가 만들어지고 나서 lastArticleId가 3으로 세팅되어햐 함으로 코드 실행 순서가 makeTestData 다음
    // 코드의 순서를 잘 지켜주는 것도 중요
    
    System.out.println("== 자바 텍스트 게시판 시작 ==");
    while(true) {
      System.out.println("명령) ");
      String cmd = sc.nextLine();

      if (cmd.equals("/usr/article/write")) { // 2. /usr/article/write 라고 입력하면 게시물 제목, 내용 입력받기
        System.out.println("== 게시물 작성 ==");
        System.out.println("제목 : ");
        String subject = sc.nextLine();
        System.out.println("내용 : ");
        String content = sc.nextLine();

        // 3. 생성된 게시물 정보를 Article 클래스의 객체로 저장 후 문장으로 출력
        int id = ++lastArticleId;
        // 이 코드로는 게시물이 저장되지 않음 -> articles.add(article); 로 게시물을 리스트에 저장
        Article article = new Article(id, subject, content); // 5. 생성자를 이용해서 게시물 객체를 쉽게 만들기
        lastArticle = article;

        articles.add(article); // 리스트에 저장

        // 4. toString 메서드를 오버라이드 하여 Article 객체가 문장으로 출력될 때, 좀 더 설명적으로 나오도록
        System.out.println("생성된 게시물 객체: " + article.toString());
        System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);      
      }
      // 7. /usr/article/list 로 입력하면 게시물리스트 출력, 시작
      else if (cmd.equals("/usr/article/list")) {
        if(articles.isEmpty()) {
          System.out.println("현재 게시물이 존재하지 않습니다.");
          continue;
        }

        System.out.println("== 게시물 리스트 ==");

        System.out.println("번호 | 제목");

        // 9. 게시물 리스트에서 출력을 최신순으로
        for (int i = articles.size() - 1; i >= 0; i--) { // articles.size() - 1: 인덱스는 0부터 시작
          Article article = articles.get(i);
          System.out.printf("%d | %s\n", article.id, article.subject);
        }
      }
      // 6. /usr/article/detail 이라고 입력하면, 가장 마지막에 입력받은 게시물의 상세정보 출력
      else if (cmd.equals("/usr/article/detail")) {
        if(articles.isEmpty()) { // 게시물이 하나도 없는 경우
          System.out.println("게시물이 존재하지 않습니다.");
          continue;
        }

        // 11. lastArticle 변수의 필요성을 제거
        Article article =  articles.get(articles.size() -1); // lastArticle 변수 대신 articles의 인덱스를 활용

        // article에는 articles.get(articles.size() -1)의 주소값이 들어가고
        if(article == null) { // 그 주소값이 null이면. 마지막 번호로 접근했는데 그 게시물이 없는 경우
          System.out.println("해당 게시물이 존재하지 않습니다.");
          continue;
        }
        System.out.println("== 게시물 상세보기 ==");
        System.out.printf("번호 : %d\n", article.id);
        System.out.printf("제목 : %s\n", article.subject);
        System.out.printf("내용 : %s\n", article.content);
      } else if (cmd.equals("exit")) { // 1. exit 명령이 나올 때 까지 계속 입력받기
        System.out.println("프로그램을 종료합니다.");
        break; // 반복문 빠져나옴
      }
      else {
        System.out.println("잘못된 명령어입니다.");
      }
    }
    System.out.println("== 자바 텍스트 게시판 종료 ==");
    sc.close();
  }
}
class Article {
  int id;
  String subject;
  String content;

  // 5. 생성자를 이용해서 게시물 객체를 쉽게 만들기
  public Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }

  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}
```
---
### 2. URL 파라미터 개념
1. String.split 메소드를 이용해서 큰 문장을 작은 문장들로 나누기
2. String.split 메소드를 여러번 사용해서 조금 더 세밀한 정보를 얻어내기
3. Integer.parseInt 를 사용해서 문장을 정수화 하기
4. 리스트 2개를 사용하여, 파라미터 이름들과 값들을 따로 담기
5. 쿼리스트링을 리스트를 이용하여 관리할 때 불편한점 설명
6. 쿼리스트링을 분석하여 분리한 데이터를 Map에 저장
7. 파싱로직을 매번 복붙해서 사용하는 비효율을 제거하기 위해 Util.getParms 메서드 도입
8. Util.getParamsFromUrl 를 오류 기반으로 문제 해결, 구조 및 개선
9. url로 부터 urlPath 부분만 가져오기
10. Util을 직접 이용하는 것보다 더 좋은 방법 설명
11. Rq가 Util한테 일을 최대한 적게 시키도록 구조개선
12. if문을 사용하지 않고 Rq가 Util을 사용하도록 구조 개선
---
1. String.split 메소드를 이용해서 큰 문장을 작은 문장들로 나누기

이 링크를 가지고 쿼리 파라미터를 알아보자. 도메인+ URL Path+쿼리 파라미터로 이루어져 있다.
[https://search.naver.com/search.naver?ie=UTF-8&sm=whl_hty&query=사과](https://search.naver.com/search.naver?ie=UTF-8&sm=whl_hty&query=%EC%82%AC%EA%B3%BC)

- [search.naver.com](https://search.naver.com) ← 도메인
- search.naver ← URL Path
- [ie=UTF-8&sm=whl_hty&query=사과](https://search.naver.com/search.naver?ie=UTF-8&sm=whl_hty&query=%EC%82%AC%EA%B3%BC) ← 쿼리 파라미터

**쿼리 파라미터란?**

- 파라미터 이름=파라미터값
- String 문자열에는 split(”기준”)이 있음
    - ex. split(”&”) ← &을 기준으로 쪼갠다

String queryString = "a=1&b=2&c=3";
- a=1, b=2, c=3으로 쪼개고 싶다
- 쪼개면 a=1&b=2&c=3 문장 하나가 아니라 3개의 a=1, b=2, c=3 ***문장들이 되어버림***

***즉, 배열에 담아야 한다.***

위치: /../test/java/AppTest.java
```java
public class AppTest {
	public static void main(String[] args) {
		// 파라미터 분석
		String queryString = "a=1&b=2&c=3";
		// a=1, b=2, c=3으로 쪼개고 싶다
		String[] queryStringBits = queryString.split("&");
		// 문장들을 배열에 담는다
	}
}
```
---
2. String.split 메소드를 여러번 사용해서 조금 더 세밀한 정보를 얻어내기

- a=1 ← 각각이 하나의 쿼리 스트링
- b=2 ← b가 파라미터 name
- c=3 ← 3이 파라미터 value

***“=”을 기준으로 쪼갠다***

- [a, 1] ← 0번째가 파라미터 name
- [b, 2] ← 1번째가 파라미터 value
- [c, 3]

```java
public class AppTest {
	public static void main(String[] args) {
		// 파라미터 분석
		String queryString = "a=1&b=2&c=3";
		// a=1, b=2, c=3으로 쪼개고 싶다
		String[] queryStringBits = queryString.split("&");
		// 문장들을 배열에 담는다
		
		for(String bit : queryStringBits) {
      String[] bitBits = bit.split("=");
      String paramName = bitBits[0];
      String paramValue = bitBits[1];
    }
  }
}
```
---
3. Integer.parseInt 를 사용해서 문장을 정수화 하기

- a=1, b=2, c=3을 특정 변수에 담고 싶다
- paramValue는 문자열인데 ***Integer.parseInt***를 붙이면 정수로 변환해줌

```java
public class AppTest {
	public static void main(String[] args) {
		// 파라미터 분석
		String queryString = "a=1&b=2&c=3";
		// a=1, b=2, c=3으로 쪼개고 싶다
		String[] queryStringBits = queryString.split("&");
		// 문장들을 배열에 담는다
		
		int a = 0;
		int b = 0;
		int c = 0;	
		
		for(String bit : queryStringBits) {
			String[] bitBits = bit.split("=");
			String paramName = bitBits[0];
			String paramValue = bitBits[1];
			
			if(paramName.equals("a")) {
				a = Integer.parseInt(paramValue);
			} else if(paramName.equals("b")) {
				b = Integer.parseInt(paramValue);
			} else {
				c = Integer.parseInt(paramValue);
			}
		}
	}
}
```
---
4. 리스트 2개를 사용하여, 파라미터 이름들과 값들을 따로 담기

"a=1&b=2&c=3" → "a=1&b=2&c=3&d=4"

***파라미터에 새로운 값이 추가된 경우 변수와 조건문을 계속 추가해주는 것은 비효율적!***

- 코드가 변했을 때 계속 수정해주는 것은 유연하지 못한 코드 ← 안 좋은 코드
- 값을 관리하는 두 개의 공간을 만든다
- 단, 배열로 만들면 사이즈가 정해져 있기 때문에 List로 담기

paramName : [a, b, c, d]

paramValue : [1, 2, 3, 4]

→ "c=1&b=2&a=3" 순서가 바뀌어도 ok.

→ "a=1&b=2&c=3&d=4" 값이 추가되어도 ok.

```java
public class AppTest {
	public static void main(String[] args) {
		// 파라미터 분석
		String queryString = "a=1&b=2&c=3";
		// a=1, b=2, c=3으로 쪼개고 싶다
		String[] queryStringBits = queryString.split("&");
		// 문장들을 배열에 담는다
		
		List<String> paramNames = new ArrayList<>();
		List<Integer> paramValues = new ArrayList<>();
		
		for(String bit : queryStringBits) {
			String[] bitBits = bit.split("=");
			String paramName = bitBits[0];
			String paramValue = bitBits[1];

		paramNames.add(paramName);
		paramValues.add(Integer.parseInt(paramValue));
		
		for(int i = 0; i < paramNames.size(); i++) {
			String paramName = paramNames.get(i);
			int paramValue = paramValues.get(i);
			}
		}
	}
}
```
---
5. 쿼리스트링을 리스트를 이용하여 관리할 때 불편한점 설명

name과 value를 따로 저장하고 있기 때문에 그 저장된 값을 매칭시키면서 봐줘야 한다.

ex. 동아리 명부와 전화번호를 두 개의 엑셀 파일로 만들어 저장해두면 회원명과 전화번호를 각각의 파일에서 매칭시켜 번갈아 보며 확인해야됨

게시물 수정할 때,
- id=20&subject=자바수업&content=내용&writerName=김철수
- 이런 데이터가 들어왔을 때 paramNames의 content와 paramValues의 내용을 일치시키기 위해 그 위치를 알아야 한다

- ***int findIndex = paramNames.indexOf(”content”); ← 위치 파악***
- ***paramValues.get(findIndex) ← 파악된 위치의 값을 가져옴***

→ 매번 name과 value를 일치시키는 불편함이 존재한다!

```java
public class AppTest {
	public static void main(String[] args) {
		String queryString = "id=20&subject=자바수업&content=내용&writerName=김철수";
		String[] queryStringBits = queryString.split("&");
		
		List<String> paramNames = new ArrayList<>();
		List<String> paramValues = new ArrayList<>();
		
		for(String bit : queryStringBits) {
			String[] bitBits = bit.split("=");
			String paramName = bitBits[0];
			String paramValue = bitBits[1];

		paramNames.add(paramName);
		paramValues.add(Integer.parseInt(paramValue));
		
		int findIndex = paramNames.indexOf("content");
		System.out.println(paramValues.get(findIndex));
		}
	}
}
```
---
6. 쿼리스트링을 분석하여 분리한 데이터를 Map에 저장

위 어려움을 개선하는 방법: ***Map*** 도입

Map<String, String> ← 둘 다 문자열을 받는다

- 첫 번째 key값 String은 고정!

HashMap은 순서를 보장하지 않기 때문에 내용을 출력해서 보면 뒤죽박죽

- 어차피 key를 확인해서 data에 접근할 수 있기 때문
- LinkedHashMap은 순서 보장

```java
public class AppTest {
	public static void main(String[] args) {
		String queryString = "id=20&subject=자바수업&content=내용&writerName=김철수";
		String[] queryStringBits = queryString.split("&");
		
		Map<String, String> params = new LinkedHashMap<>();
		
		for(String bit : queryStringBits) {
			String[] bitBits = bit.split("=");
			params.put(bitBits[0], bitBits[1]);
		}
		
		System.out.println("==반복문을 사용하여 순회 출력==");
		for(String paramName : params.keySet()) {
			String paramValue = params.get(paramName);
			System.out.printf("%s : %s\n", paramName, paramValue);
		}
	}
}
```
---
7. 파싱로직을 매번 복붙해서 사용하는 비효율을 제거하기 위해 Util.getParms 메서드 도입

쿼리스트링을 2개 이상 분석해야 하는 경우
- 반복적으로 사용하는 코드의 경우 객체지향적으로 처리하는 것이 좋다
  - [기존의 쿼리스트링+분석 클래스]를 쿼리 스트링만 준비하는 클래스와 별도로 분석하는 클래스로 나눈다
    - 쿼리 스트링을 별도로 분석하는 클래스: `Util`

Map<String, String> params1 = Util.getParams(queryString1);
- 위 코드를 만들고 Util 클래스를 만든다
- Util.getParams 메서드는 인자값 String queryStr을 받아 Map<String, String> 타입이기 때문에
- Util 클래스에서 getParams 메서드를 정의할 때 static Map<String, String> getParams(String queryStr) {
- 


```java
public class AppTest {
  public static void main(String[] args) {
    // 파라미터 분석
    String queryString1 = "id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=20";
    Map<String, String> params1 = Util.getParams(queryString1);
    System.out.println(params1);

    String queryString2 = "id=20&subject=자바&content=내용2&writerName=김수정&hitCount=40";
    Map<String, String> params2 = Util.getParams(queryString2);
    System.out.println(params2);

  }
}

class Util {
  // 메인 메서드가 static이기 때문에 Util을 객체화하지 않고 사용할 수 있는 static 클래스로 만들기
  static Map<String, String> getParams(String queryStr) {
    Map<String, String> params = new LinkedHashMap<>();
    String[] queryStrBits = queryStr.split("&");

    for(String bit : queryStrBits) {
      String[] bitBits = bit.split("=");

      params.put(bitBits[0], bitBits[1]); // 0번째 key, 1번째 value
    }
    return params;
  }
}
```

---
8. Util.getParamsFromUrl 를 오류 기반으로 문제 해결, 구조 및 개선: Util.getParamsFromUrl 구현


   1. `?` 기준으로 앞 뒤를 나눈다.
   2. 배열의 index 1번째 값을 가져와서 `&`를 기준으로 쪼갠다.
   3. 2번의 결과를 `=`을 기준으로 쪼갠다.
   4. 2 ~ 3번을 한 결과를 map의 담는다.
   - index 0, key
   - index 1, value
   5. 담은 결과를 리턴하여 해당 결과를 출력한다.


```java
public class AppTest {
  public static void main(String[] args) {
    // 파라미터 분석
    String url = "/usr/article/write?id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30";
    Map<String, String> params = Util.getParamsFromUrl(url);
    System.out.println(params);

    System.out.println(params.get("id")); // 20
    System.out.println(params.get("subject")); // 자바수업
    System.out.println(params.get("content")); // 내용
    System.out.println(params.get("writerName")); // 김철수
    System.out.println(params.get("hitCount")); // 30
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2); // 특수문자(?과 같은)를 split으로 나눌 때 \\? 붙여줌
    // 쪼개기만 하면 배열 객체 주소가 나오며 2의 의미는 ?를 기준으로 2등분으로 쪼개주라는 뜻
    // ?가 3개일 경우 2를 통해 2개로 쪼갤 수 있다. 2는 limit값

    if(urlBits.length == 1) { // 길이가 1개라는 것은 쪼개지지 않았음을 의미
      return params;
    }

    String queryStr = urlBits[1]; // id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2); // =을 기준으로 쪼개는데 2개 이상으로 쪼개지 않겠다
      // ex. id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30&cals=[10+20=]
      // limit 2를 하지 않으면 `cals=[10+20=]`은 `[10+20`으로 쪼개짐
      // limit 2를 해주면 `[10+20=]`으로 쪼개진다

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }
}
```

---
9. url로 부터 urlPath 부분만 가져오기

/usr/article/write < urlPath

```java
public class AppTest {
  public static void main(String[] args) {
    // 파라미터 분석
    String url = "/usr/article/write?id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30";
    Map<String, String> params = Util.getParamsFromUrl(url);
    System.out.println(params);

    // String urlPath: String으로 받겠다고 했으니 
    String urlPath = Util.getPathFromUrl(url);
    System.out.println(urlPath);

  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  // 리턴 타입을 String으로 만들어야 함
  static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0]; // /usr/article/write
  }
}
```
---
10. Util을 직접 이용하는 것보다 더 좋은 방법 설명

/usr/article/write?id=20&subject=자바수업&content=내용

지금까지의 Util

    1. URL Path을 가져오는 역할
        - /usr/article/write
    2. 쿼리 스트링을 분석해서 파라미터를 찾아내는 역할
        - id=20&subject=자바수업&content=내용

개선

- Rq를 도입하여 Rq가 중간다리 역할을 해주도록 구현
- Util을 모르더라도 Rq를 이용해서 Rq가 Util에 요청 
  - URL Path을 가져오고 파라미터를 가져오도록

현재 Rq의 문제점

- A(부장), B(나), C만 발급할 수 있는 문서
- A(문서 발급 요청) -> B
- B(문서 발급 요청) -> C
- C(문서 발급 완료) -> B
- B(발급된 문서 전달) -> A
- A(문서 발급 재요청) -> B
- A의 요청으로 B가 C에 계속 왔다갔다 하는 것은 비효율적!

개선

- B가 C의 문서를 기억하고 있다면?
- B가 기억한 문서를 A에게 전달 가능!

```java
public class AppTest {
  public static void main(String[] args) {
    // Rq가 url을 품고 태어나려면 생성자 메서드가 있어야 함
    Rq rq = new Rq("/usr/article/write?id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30");
    Map<String, String> params = rq.getParams();
    System.out.println(params);
    System.out.println(rq.getParams());
    System.out.println(rq.getParams());

    String urlPath = rq.getUrlPath();
    System.out.println(urlPath);
    System.out.println(rq.getUrlPath());
    System.out.println(rq.getUrlPath());
  }
}

class Rq {
  String url;

  Rq(String url) { // 생성자 메서드로 url 받아올 수 있도록
    this.url = url;
  }

  public Map<String, String> getParams() { // Util에게 요청함
    return Util.getParamsFromUrl(url);
  }

  public String getUrlPath() { // Util에게 요청함
    return Util.getPathFromUrl(url);
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    System.out.println("getParamsFromUrl 실행!!"); // 실행 메시지가 매번 출력됨 = 요청할 때마다 계속 방문
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    System.out.println("getPathFromUrl 실행!!");
    return url.split("\\?", 2)[0];
  }
}
```
---
11. Rq가 Util한테 일을 최대한 적게 시키도록 구조개선

Rq는 객체가 만들어지자마자 url을 기억한다

```java
public class AppTest {
  public static void main(String[] args) {
    Rq rq = new Rq("/usr/article/write?id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30");
    // Rq는 객체가 만들어지자마자 url을 기억한다
    Map<String, String> params = rq.getParams(); // 첫 요청 - 이때 rq가 util 한 번 방문하고 그 이후엔 기억한 내용 보여줌.
    System.out.println(params);
    System.out.println(rq.getParams());
    System.out.println(rq.getParams());

    String urlPath = rq.getUrlPath();
    System.out.println(urlPath);
    System.out.println(rq.getUrlPath());
    System.out.println(rq.getUrlPath());
  }
}

class Rq {
  String url;
  // rq가 만들어지자마자 최초의 params와 urlPath는 비어있는 상태
  Map<String, String> params; 
  String urlPath;

  Rq(String url) {
    this.url = url; // 객체가 태어나자마자 url을 저장
  }

  public Map<String, String> getParams() {
    if(params == null) { // 최초의 상태가 null. null이면 데이터를 채워줘야
      params = Util.getParamsFromUrl(url); // util에 한 번 다녀와서 url을 기억한다
    }

    return params; // 두 번째 요청이 들어왔을 때는 params가 null이 아니므로 기억한 params를 줄 수 있음
  }

  public String getUrlPath() {
    if(urlPath == null) {
      urlPath = Util.getPathFromUrl(url);
    }

    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    System.out.println("getParamsFromUrl 실행!!"); // rq가 기억한 뒤로 실행 메시지가 한 번만 나오게 됨
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    System.out.println("getPathFromUrl 실행!!");
    return url.split("\\?", 2)[0];
  }
}
```
---
12. if문을 사용하지 않고 Rq가 Util을 사용하도록 구조 개선

생성자 메서드를 통해
조건문을 사용하지 않고 
rq가 params, urlPath를 기억하도록 개선

```java
public class AppTest {
  public static void main(String[] args) {
    Rq rq = new Rq("/usr/article/write?id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30");
    Map<String, String> params = rq.getParams();
    System.out.println(params);
    System.out.println(rq.getParams());
    System.out.println(rq.getParams());

    String urlPath = rq.getUrlPath();
    System.out.println(urlPath);
    System.out.println(rq.getUrlPath());
    System.out.println(rq.getUrlPath());
  }
}

class Rq {
  String url;
  Map<String, String> params;
  String urlPath;

  // 생성자 메서드가 제일 먼저 실행되기 때문에 실행 메시지가 위로 올라감
  Rq(String url) { // 조건문을 사용하지 않고 rq가 params, urlPath를 기억함
    this.url = url;
    params = Util.getParamsFromUrl(this.url); // 객체가 생성되자마자
    urlPath = Util.getPathFromUrl(this.url); // 데이터가 알아서 들어간다
    // url은 String url을 뜻하고, url이 아닌 this.url을 넘겨주는 것이 좋다
  }

  public Map<String, String> getParams() {
    return params;
  }

  public String getUrlPath() {
    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    System.out.println("getParamsFromUrl 실행!!");
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    System.out.println("getPathFromUrl 실행!!");
    return url.split("\\?", 2)[0];
  }
}
```
---
### 3. URL 파라미터 분석 실습
35-39강까지

1. 복잡한 명령어를 처리하기 위해, Rq 도입
2. Rq도입하여 게시물 상세보기 시에, 원하는 게시물 번호 입력
3. 입력된 id에 대해서 유효성 체크
4. orderBy=idDesc 파라미터에 의한 정렬방법 변경
5. Util.reverseList 를 이용해서 정렬로직 간소화
---

```java
public class Main {
  static void makeTestData(List<Article> articles) {
    articles.add(new Article(1, "제목1", "내용1"));
    articles.add(new Article(2, "제목2", "내용2"));
    articles.add(new Article(3, "제목3", "내용3"));
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    List<Article> articles = new ArrayList<>();

    makeTestData(articles);

    int lastArticleId = articles.get(articles.size() - 1).id;

    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      System.out.print("명령) ");
      String cmd = sc.nextLine();

      // 1. 복잡한 명령어를 처리하기 위해, Rq 도입
      Rq rq = new Rq(cmd); // rq 도입부분. cmd가 url임

      if (rq.getUrlPath().equals("/usr/article/write")) {
        System.out.println("== 게시물 작성 ==");
        System.out.print("제목 : ");
        String subject = sc.nextLine();

        System.out.print("내용 : ");
        String content = sc.nextLine();

        int id = ++lastArticleId;

        Article article = new Article(id, subject, content);

        articles.add(article);

        System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        if(articles.isEmpty()) {
          System.out.println("현재 게시물이 존재하지 않습니다.");
          continue;
        }
        
        // 4. orderBy=idDesc 파라미터에 의한 정렬방법 변경
        // /usr/article/list?orderBy=idDesc -> 내림차순 정렬
        // /usr/article/list?orderBy=idAsc -> 오름차순 정렬
        Map<String, String> params = rq.getParams(); // params를 가져옴
        boolean orderByIdDesc = true; // 4-1. boolean orderByIdDesc 값을 만든다. -> true이면 역순정렬
        if(params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) { // 4-2. params에 orderBy 값이 있는지 체크
          // orderBy가 있다면 그 값이 idAsc인지 체크
          orderByIdDesc = false; // 4-2. 참이라면 게시물 리스트를 정순으로 출력
          // Collections.reverse(articles); 를 사용하지 않는 이유: 원본 리스트 값을 뒤집어 원본 훼손
        }

        System.out.println("== 게시물 리스트 ==");

        System.out.println("번호 | 제목");
        
        // 5. Util.reverseList 를 이용해서 정렬로직 간소화
        List<Article> sortedArticles = articles; // articles는 정렬되지 않는 순수한 로직을 담고 있음 

        // 4-3. orderBy 값에 따라서 역순순회, 정순순회
        if(orderByIdDesc) { // 역순정렬
          sortedArticles = Util.reverseList(sortedArticles);
        }
        sortedArticles.forEach(
            article -> System.out.printf("%d | %s\n", article.id, article.subject)
        );

        // 2. Rq도입하여 게시물 상세보기 시에, 원하는 게시물 번호 입력
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        if(articles.isEmpty()) {
          System.out.println("현재 게시물이 존재하지 않습니다.");
          continue;
        }

        // /usr/aritcle/detail?id=1
        // rq의 2가지 기능: urlPath(/usr/aritcle/detail), urlParams(id=1)
        Map<String, String> params = rq.getParams(); // urlParams(id, 1)(key, value)을 가져오는 역할
        // int id = Integer.parseInt(params.get("id")); // Map에서 저장한 타입이 String이기 때문에 "id" -> 정수화

        // 3. 입력된 id에 대해서 유효성 체크
        if(!params.containsKey("id")) { // containsKey: 해당 키로 접근했을 때 Map 안에서 있는지 확인함. 있으면 true
          System.out.println("id 값을 입력해주세요."); // containsKey가 false의 경우
          continue;
        }
        int id = 0; // 지역변수 id 세팅
        try {
          id = Integer.parseInt(params.get("id")); // try-catch 안의 id가 지역변수이기 때문에
        } catch (NumberFormatException e) { // 예외처리를 해줘야 오류 발생시 터지지 않음
          System.out.println("id를 정수형태로 입력해주세요.");
          continue;
        }
        
        // Article article = articles.get(id); 가 안 되는 이유
        // /usr/article/detail?id=1 했을 때 인덱스 1번 게시물의 번호는 2 
        
        // 유효성 검사가 잘 이루어져야
        if(id > articles.size()) {
          System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
          continue;
        }

        // IndexOutOfBoundsException이 나올 것을 방지하기 위해
        // if(id > articles.size()) { 아래에 배치
        Article article = articles.get(id - 1);

        System.out.println("== 게시물 상세보기 ==");
        System.out.printf("번호 : %d\n", article.id);
        System.out.printf("제목 : %s\n", article.subject);
        System.out.printf("내용 : %s\n", article.content);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못 된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    sc.close();
  }
}

class Article {
  int id;
  String subject;
  String content;

  Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }

  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}

class Rq {
  String url;
  Map<String, String> params;
  String urlPath;

  Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }

  public Map<String, String> getParams() {
    return params;
  }

  public String getUrlPath() {
    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0];
  }

  // 이 함수는 원본리스트를 훼손하지 않고, 새 리스트를 만듭니다. 즉 정렬이 반대인 복사본리스트를 만들어서 반환합니다.
  // 제너릭 타입 <T>
  // 새로운 리스트를 다시 만들어서 그 리스트를 뒤짚어줌
  public static<T> List<T> reverseList(List<T> list) {
    List<T> reverse = new ArrayList<>(list.size());
    for ( int i = list.size() - 1; i >= 0; i-- ) {
      reverse.add(list.get(i));
    }
    return reverse;
  }
}
```
---
### 4. SearchKeyword 도입
40~42강
1. 게시물 중 특정키워드에 관련된 것들만 따로 필터링해서 새 리스트에 저장하는 방법
2. 테스트 게시물을 100개로 늘림
3. searchKeyword를 이용한 게시물 검색어 기능 구현
---
1. 게시물 중 특정키워드에 관련된 것들만 따로 필터링해서 새 리스트에 저장하는 방법

테스트 케이스를 만들어 필요한 데이터를 추가한 후 `자바 문자열 포함 여부`등을 검색하여 내용 찾아보고 테스트케이스를 공부할 수 있다.

테스트를 해보지 않고 원본 코드에 바로 도입할 경우 원본 코드가 무너질 수 있으니 테스트 적극 활용할 것!
```java
public class SearchKeywordTest { // 위치 src/test/java/SearchKeywordTest.java
  public static void main(String[] args) {
    List<Article> articles = new ArrayList<>();
    IntStream.rangeClosed(1, 5)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
    
    // 그외 게시물 추가
    articles.add(new Article(6, "자바는 무슨 언어인가요?", "자바는 객체지향 프로그래밍 언어입니다."));
    articles.add(new Article(7, "코딩 실력 빨리 늘려면 어떻게 하나요?", "반복학습이 정답이다."));
    
    // 제목이 포함된 항목 찾기
    String searchKeyword = "제목";
    // 찾은 항목을 담을 리스트
    List<Article> filteredArticles = new ArrayList<>();
    
    // 향상된 for문
    // articles의 0~6번째 article의 subject에서 searchKeyword가 포함된 항목을 찾아 filteredArticles에 저장
    for(Article article : articles) {
      if(article.subject.contains(searchKeyword)) {
        filteredArticles.add(article);
      }
    }
    System.out.println(filteredArticles);
  }
}

// 테스트에 필요한 데이터 추가
class Article {
  int id;
  String subject;
  String content;
  Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }
  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}
```
2. 테스트 게시물을 100개로 늘림
Main클래스의 makeTestData 수정
```java
// 생략
static void makeTestData(List<Article> articles) {
    /*
    for(int i = 1; i <= 100; i++) {
      articles.add(new Article(i, "제목" + i, "내용" + i);
    }
    */
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }
// 생략
```
3. searchKeyword를 이용한 게시물 검색어 기능 구현
```java
public class Main {
  public static void main(String[] args) {
// 생략
    // if가 아니라 `else if`이지만 정리에는 if로 표기함
    if (rq.getUrlPath().equals("/usr/article/list")) { // else if
      if (articles.isEmpty()) {
        System.out.println("현재 게시물이 존재하지 않습니다.");
        continue;
      }

      Map<String, String> params = rq.getParams();
// 검색 기능 시작
// articles : 현재 정렬되지 않은 1 ~ 100개의 게시물 리스트
      List<Article> filteredArticls = articles;

      // searchKeyword가 들어왔는지 확인하는 코드
      if (params.containsKey("searchKeyword")) {
        String searchKeyword = params.get("searchKeyword");
        filteredArticls = new ArrayList<>(); // 초기화를 시켜줌. 새롭게 필터링한 결과를 담아줄 것

        for (Article article : articles) {
          boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);

          if (matched) filteredArticls.add(article);
        }
      }
// 검색 기능 끝

// 정렬 로직 시작
      boolean orderByIdDesc = true;
      if (params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) {
        orderByIdDesc = false;
      }
      // 필터링된 값을 sortedArticles에 공유함으로써 출력될 수 있도록
      // searchKeyword가 입력되지 않으면 searchKeyword를 필터링하는 코드가 실행되지 않고
      // 정렬되지 않은 articles이다
      List<Article> sortedArticles = filteredArticls;

      if (orderByIdDesc) {
        sortedArticles = Util.reverseList(sortedArticles);
      }
      // 정렬 로직 끝
      System.out.println("== 게시물 리스트 ==");
      System.out.println("번호 | 제목");

      sortedArticles.forEach(
          article -> System.out.printf("%d | %s\n", article.id, article.subject)
      );

    }
  }
}
// 생략
```


---
### 5. 메서드로 분리
43~47강
1. 명령어 usr/article/list 에 대한 처리를 별도의 함수로 분리
2. actionUsrArticleDetail 메서드 구현
3. actionUsrArticleWrite 메서드 구현
4. actionUsrArticleModify 메서드 구현
5. 게시물 삭제 기능 구현, findById 메서드 도입

현재 기능
- /usr/article/list
- /usr/article/detail
- /usr/article/write
기능이 추가될수록 코드의 길이는 더 늘어날 것
- 실행코드의 길이를 줄이기 위해 별도의 메서드로 만들어서 처리

게시물 수정 기능 구현
1. actionUsrArticleModify(); 만들기
  /usr/article/modify?id=1 명령을 사용할 수 있도록
2. 유효성 검사 필수
  - `id`파라미터 제대로 입력되었는가
  - 입력되었다면 그 값이 정수인가
  - id에 맞는 게시물이 존재하지 않는 경우
3. 명령어 처리
  - 제목: 수정된 제목
  - 내용: 수정된 내용
  - 1번 게시물이 수정되었습니다.

게시물 삭제 기능 구현
- 리스트에서 0번째를 삭제할 경우 다음 값이 0번째가 됨
- findById 도입
```java
public class Main {
  static void makeTestData(List<Article> articles) {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    List<Article> articles = new ArrayList<>();
    makeTestData(articles);
    int lastArticleId = articles.get(articles.size() - 1).id; // 100
    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      System.out.print("명령) ");
      String cmd = sc.nextLine();

      Rq rq = new Rq(cmd);

      if (rq.getUrlPath().equals("/usr/article/write")) {
        // 3. actionUsrArticleWrite 메서드 구현
        actionUsrArticleWrite(sc, articles, lastArticleId);
        // actionUsrArticleWrite 내부에서 증가시키면 메서드 종료 시 함께 종료되어 증가되지 않음
        lastArticleId++; // 번호 100 이상으로 증가될 수 있도록
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        // 1. 명령어 usr/article/list 에 대한 처리를 별도의 함수로 분리
        actionUsrArticleList(rq, articles); // /list에서 필요한 rq, articles 넘겨주기
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        // 2. actionUsrArticleDetail 메서드 구현
        actionUsrArticleDetail(rq, articles);
      } else if (rq.getUrlPath().equals("/usr/article/modify")) {
        // 4. actionUsrArticleModify 메서드 구현
        actionUsrArticleModify(sc, rq, articles);
      } else if (rq.getUrlPath().equals("/usr/article/delete")) {
        // 5. 게시물 삭제 기능 구현, findById 메서드 도입
        actionUsrArticleDelete(rq, articles);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    sc.close();
  }

  // 5. 게시물 삭제 기능 구현, findById 메서드 도입
  private static void actionUsrArticleDelete(Rq rq, List<Article> articles) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    // 입력한 id와 리스트의 id가 일치하는지 확인해야 함
    // 리스트는 삭제하면 데이터 순서가 땡겨지기 때문에
    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    articles.remove(article);

    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }
  
  // 4. actionUsrArticleModify 메서드 구현
  private static void actionUsrArticleModify(Scanner sc, Rq rq, List<Article> articles) {
    if(articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    if(!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    System.out.print("새 제목 : ");
    article.subject = sc.nextLine();
    System.out.print("새 내용 : ");
    article.content = sc.nextLine();
    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }

  // 3. actionUsrArticleWrite 메서드 구현
  private static void actionUsrArticleWrite(Scanner sc, List<Article> articles, int lastArticleId) {
    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = sc.nextLine();
    System.out.print("내용 : ");
    String content = sc.nextLine();
    int id = ++lastArticleId;
    Article article = new Article(id, subject, content);
    articles.add(article);
    System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
  }

  // 2. actionUsrArticleDetail 메서드 구현
  private static void actionUsrArticleDetail(Rq rq, List<Article> articles) {
    if(articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    if(!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }
    // 만일 1번 게시물이 삭제되었다면 리스트는 순서가 땡겨지기 때문에
    // /usr/article/detail?id=1을 하면 2번 게시물이 보여지게 됨
    // findById 도입
    Article article = finById(articles, id);
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }

  // 1. 명령어 usr/article/list 에 대한 처리를 별도의 함수로 분리
  private static void actionUsrArticleList(Rq rq, List<Article> articles) {
    if(articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      // 함수를 종료시키는 return 사용
      return; // 기존 continue에서 반복문 밖으로 나왔기 때문에 return으로 수정
    }
    Map<String, String> params = rq.getParams();
    // 검색 기능 시작
    List<Article> filteredArticls = articles;
    if(params.containsKey("searchKeyword")) {
      String searchKeyword = params.get("searchKeyword");
      filteredArticls = new ArrayList<>();
      for(Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);
        if(matched) filteredArticls.add(article);
      }
    }
    // 검색 기능 끝
    // 정렬 로직 시작
    boolean orderByIdDesc = true;
    if(params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) {
      orderByIdDesc = false;
    }
    List<Article> sortedArticles = filteredArticls;
    if(orderByIdDesc) {
      sortedArticles = Util.reverseList(sortedArticles);
    }
    // 정렬 로직 끝
    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");
    sortedArticles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }
  // 5. 게시물 삭제 기능 구현, findById 메서드 도입
  private static Article finById(List<Article> articles, int id) {
    /*
    for (Article article : articles) { // articles의 0, 1, 2번째가 article에 들어감
      if (article.id == id) { // article.id와 id(내가 입력한 id)가 일치할 때
        return article;
      }
    }
    */

    return articles.stream()
            .filter(article -> article.id == id)
            .findFirst() // 첫 번째 요소 찾기
            .orElse(null);
  }
}

class Article {
  int id;
  String subject;
  String content;

  Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }

  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}

class Rq {
  String url;
  Map<String, String> params;
  String urlPath;

  Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }

  public Map<String, String> getParams() {
    return params;
  }

  public String getUrlPath() {
    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0];
  }
  // 이 함수는 원본리스트를 훼손하지 않고, 새 리스트를 만듭니다. 즉 정렬이 반대인 복사본리스트를 만들어서 반환합니다.
  public static<T> List<T> reverseList(List<T> list) {
    List<T> reverse = new ArrayList<>(list.size());
    for ( int i = list.size() - 1; i >= 0; i-- ) {
      reverse.add(list.get(i));
    }
    return reverse;
  }
}
```
---
### 6. 리팩토링
48~51강
1. articles, articlesLastId 변수를 static 변수로 전환
2. 스캐너를 공공재로 변경하여, 언제 어디서거든 쉽게 접근하도록
3. App 클래스 도입하여, 불필요했던 static 키워드를 대부분 제거
4. 클래스별 파일 분리
---

매번 rq, articles 등을 넘겨줘야 했음
```
} else if (rq.getUrlPath().equals("/usr/article/detail")) {
    actionUsrArticleDetail(rq, articles);
```

ver1) 변경 전
```
class Main{
  static void main() {
    int a = 10; // main 안에서 만들어진 지역변수
    int b = 20;
    
    int rs1 = plus(a, b); // 매개변수 값으로 a, b를 전달
    int rs2 = minus(a, b); // 지역변수를 메서드에서 쓸 수 없기 때문에 인자 값으로 넘기고 있음
  }
  
  static int plus(int a, int b) {} // static인 main에서 호출되려면 메서드도 static이어야 함
  static int minus(int a, int b) {}

}
```

ver2) 변경 후
```
class Main{
  int a = 10; // 전역변수
  int b = 20;
  
  static void main() {
    int rs1 = plus(); // 전역변수 a,b를 인자 값으로 넘겨줄 필요 없음
    int rs2 = minus();
  }
  
  static int plus() { // 매개변수 값을 받지 않아도
    return a + b; // 가능!
  }
  static int minus() {
    return a - b; // 가능!
  }
}
```
#### 싱글톤패턴

게시판이 커지면 Article, Member, Reply 등에서 모두 스캐너를 사용해야 한다. 매번 스캐너를 열고 닫는 것보다
스캐너를 공공재로 변경해주고 가져와 사용할 수 있도록 수정.

컨테이너를 도입하는 패턴 - 싱글톤 패턴
```java
// 2. 스캐너를 공공재로 변경하여, 언제 어디서거든 쉽게 접근하도록
public class Container { // 위치 text_board.container.Container.java
  public static Scanner sc;
  static { // 컨테이너를 객체화하지 않고 가져올 수 있도록 static으로 만듦
    sc = new Scanner(System.in);
  }
}
```



```java
// 2. 스캐너를 공공재로 변경하여, 언제 어디서거든 쉽게 접근하도록
import com.sbs.java.text_board.container.Container;

public class Main {
  // 1. articles, articlesLastId 변수를 static 변수로 전환
  // static 메서드는 static만 접근 가능하여 static으로 만들어줌
  static List<Article> articles = new ArrayList<>();
  static int lastArticleId = 0;
  static void makeTestData() {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }

  public static void main(String[] args) {
    makeTestData();

    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      System.out.print("명령) ");
      String cmd = Container.sc.nextLine();

      Rq rq = new Rq(cmd);

      if (rq.getUrlPath().equals("/usr/article/write")) {
        actionUsrArticleWrite();
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        actionUsrArticleList(rq);
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        actionUsrArticleDetail(rq);
      } else if (rq.getUrlPath().equals("/usr/article/modify")) {
        actionUsrArticleModify(rq);
      } else if (rq.getUrlPath().equals("/usr/article/delete")) {
        actionUsrArticleDelete(rq);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못 된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    Container.sc.close();
  }

  private static void actionUsrArticleDelete(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    articles.remove(article);

    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }

  private static void actionUsrArticleModify(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.print("새 제목 : ");
    article.subject = Container.sc.nextLine();

    System.out.print("새 내용 : ");
    article.content = Container.sc.nextLine();

    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }

  private static void actionUsrArticleWrite() {
    // lastArticleId 세팅
    lastArticleId = articles.get(articles.size() - 1).id;
    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = Container.sc.nextLine();

    System.out.print("내용 : ");
    String content = Container.sc.nextLine();

    int id = ++lastArticleId;

    Article article = new Article(id, subject, content);

    articles.add(article);

    System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
  }

  private static void actionUsrArticleDetail(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }

  private static void actionUsrArticleList(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    // 검색 기능 시작
    List<Article> filteredArticls = articles;

    if (params.containsKey("searchKeyword")) {
      String searchKeyword = params.get("searchKeyword");

      filteredArticls = new ArrayList<>();

      for (Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);

        if (matched) filteredArticls.add(article);
      }
    }
    // 검색 기능 끝

    // 정렬 로직 시작
    boolean orderByIdDesc = true;

    if (params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) {
      orderByIdDesc = false;
    }

    List<Article> sortedArticles = filteredArticls;

    if (orderByIdDesc) {
      sortedArticles = Util.reverseList(sortedArticles);
    }
    // 정렬 로직 끝

    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");

    sortedArticles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }

  private static Article finById(List<Article> articles, int id) {
    /*
    for (Article article : articles) {
      if (article.id == id) {
        return article;
      }
    }
    */

    return articles.stream()
        .filter(article -> article.id == id)
        .findFirst() // 첫 번째 요소 찾기
        .orElse(null);
  }
}

class Article {
  int id;
  String subject;
  String content;

  Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }

  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}

class Rq {
  String url;
  Map<String, String> params;
  String urlPath;

  Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }

  public Map<String, String> getParams() {
    return params;
  }

  public String getUrlPath() {
    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if (urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for (String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if (bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0];
  }

  // 이 함수는 원본리스트를 훼손하지 않고, 새 리스트를 만듭니다. 즉 정렬이 반대인 복사본리스트를 만들어서 반환합니다.
  public static <T> List<T> reverseList(List<T> list) {
    List<T> reverse = new ArrayList<>(list.size());

    for (int i = list.size() - 1; i >= 0; i--) {
      reverse.add(list.get(i));
    }
    return reverse;
  }
}
```
---
3. App 클래스 도입하여, 불필요했던 static 키워드를 대부분 제거

Main에서 호출되는 메서드들이 static일 수밖에 없어서 메모리가 낭비되고 있음
- static이 붙은 것은 프로그램이 로딩되자마자 생성됨
- 그렇기 때문에 static 프로그램을 실행하기 위해서는 static 메서드를 만들어줘야 함

코드 실행 순서
1. Main클래스에서 App객체 생성, run메서드 호출
2. App클래스에서 생성자메서드로 인스턴스 변수 생성되고
3. 요청에 따라 해당 코드 실행됨

#### App = 시작점 = 디스패처 서블릿

```java
public class App { // 위치 text_board.App.java
  // static이 제거됨
  List<Article> articles;
  int lastArticleId;

  App() { // 생성자메서드로 인스턴스 변수 생성
    articles = new ArrayList<>();
    lastArticleId = 0;
  }

  void makeTestData() {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }

  // 우리 로직의 시작점
  // Main에서 시작했을 때 붙여준 불필요한 static을 제거해줄 수 있음
  void run() {
    makeTestData();

    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      System.out.print("명령) ");
      String cmd = Container.sc.nextLine();

      Rq rq = new Rq(cmd);

      if (rq.getUrlPath().equals("/usr/article/write")) {
        actionUsrArticleWrite();
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        actionUsrArticleList(rq);
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        actionUsrArticleDetail(rq);
      } else if (rq.getUrlPath().equals("/usr/article/modify")) {
        actionUsrArticleModify(rq);
      } else if (rq.getUrlPath().equals("/usr/article/delete")) {
        actionUsrArticleDelete(rq);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못 된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    Container.sc.close();
  }

// static이 다 제거된 모습
  private void actionUsrArticleDelete(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    articles.remove(article);

    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }

  private void actionUsrArticleModify(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.print("새 제목 : ");
    article.subject = Container.sc.nextLine();

    System.out.print("새 내용 : ");
    article.content = Container.sc.nextLine();

    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }

  private void actionUsrArticleWrite() {
    lastArticleId = articles.get(articles.size() - 1).id;

    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = Container.sc.nextLine();

    System.out.print("내용 : ");
    String content = Container.sc.nextLine();

    int id = ++lastArticleId;

    Article article = new Article(id, subject, content);

    articles.add(article);

    System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
  }

  private void actionUsrArticleDetail(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }

  private void actionUsrArticleList(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    // 검색 기능 시작
    List<Article> filteredArticls = articles;

    if (params.containsKey("searchKeyword")) {
      String searchKeyword = params.get("searchKeyword");

      filteredArticls = new ArrayList<>();

      for (Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);

        if (matched) filteredArticls.add(article);
      }
    }
    // 검색 기능 끝

    // 정렬 로직 시작
    boolean orderByIdDesc = true;

    if (params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) {
      orderByIdDesc = false;
    }

    List<Article> sortedArticles = filteredArticls;

    if (orderByIdDesc) {
      sortedArticles = Util.reverseList(sortedArticles);
    }
    // 정렬 로직 끝

    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");

    sortedArticles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }

  private Article finById(List<Article> articles, int id) {
    return articles.stream()
        .filter(article -> article.id == id)
        .findFirst() // 첫 번째 요소 찾기
        .orElse(null);
  }
}
```
```java
public class Main {
  public static void main(String[] args) {
    App app = new App(); // App객체 만들어서
    app.run(); // run 메서드 호출
  }
}

class Article {
  int id;
  String subject;
  String content;

  Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }

  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}

class Rq {
  String url;
  Map<String, String> params;
  String urlPath;

  Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }

  public Map<String, String> getParams() {
    return params;
  }

  public String getUrlPath() {
    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if (urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for (String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if (bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0];
  }

  // 이 함수는 원본리스트를 훼손하지 않고, 새 리스트를 만듭니다. 즉 정렬이 반대인 복사본리스트를 만들어서 반환합니다.
  public static <T> List<T> reverseList(List<T> list) {
    List<T> reverse = new ArrayList<>(list.size());

    for (int i = list.size() - 1; i >= 0; i--) {
      reverse.add(list.get(i));
    }
    return reverse;
  }
}
```
---
4. 클래스별 파일 분리
일단 public으로 접근제한 변경
```java
public class Main {
  public static void main(String[] args) {
    App app = new App();
    app.run();
  }
}
```
```java
public class Article { // 위치 text_board.Article.java
  public int id; // private으로 막아줘야 함
  public String subject;
  public String content;
  public Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }
  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}
```
```java
public class Rq { // 위치 text_board.Rq.java
  public String url;
  public Map<String, String> params;
  public String urlPath;
  public Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }
  public Map<String, String> getParams() {
    return params;
  }
  public String getUrlPath() {
    return urlPath;
  }
}
```
```java
public class Util { // 위치 text_board.util.Util.java
  public static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);
    if (urlBits.length == 1) {
      return params;
    }
    String queryStr = urlBits[1];
    for (String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);
      if (bits.length == 1) {
        continue;
      }
      params.put(bits[0], bits[1]);
    }
    return params;
  }
  public static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0];
  }
  // 이 함수는 원본리스트를 훼손하지 않고, 새 리스트를 만듭니다. 즉 정렬이 반대인 복사본리스트를 만들어서 반환합니다.
  public static <T> List<T> reverseList(List<T> list) {
    List<T> reverse = new ArrayList<>(list.size());
    for (int i = list.size() - 1; i >= 0; i--) {
      reverse.add(list.get(i));
    }
    return reverse;
  }
}
```
___
### 7. MVC 개념 설명, 컨트롤러 도입으로 리팩토링
52~55강
1. MVC와 컨트롤러 개념
2. ArticleController 클래스 도입
3. Rq.getIntParam 메소드 개요
4. rq.getIntParam, rq.getParam 을 도입하여 소스코드 다이어트
---
1. MVC와 컨트롤러 개념

현재 App이 모든 일을 담당하고 있음

수정할 App이 할 일 
- 고객에게 요청을 받아 member와 관련된 일이면 member에게, article과 관련된 일이면 article에게

#### MVC 디자인 패턴
Model(모델): 서류 통과 심사 처리 후 입금 처리, 대출 처리 등
- 핵심 로직

View(화면)
- 보여지는 부분

Controller(컨트롤러): 은행 창구 직원(예금, 대출 등) - 서류 통과 심사
- 유효성 검사
---

#### 현재 프로젝트에 맞도록 MVC 설명
Model - 핵심로직

View - 고객이 보는 화면

Controller - 요청에 대한 유효성 검사

고객 > 은행 방문 > 청원 경찰(어떤 업무를 하러 왔는지 확인) > 은행 창구(예금, 대출)/ 필요 서류 확인 > 전산 처리 > 금고

- App(청원 경찰)
- Controller(은행 창구)
- Model(중요 업무 처리)
  - Service(은행 업무 처리)
  - Repository(은행의 금고, db 처리)
  - Dto(결과 통지서(member, article의 id, subject, content 등의 생성과 초기화가 하나의 양식임))

컨트롤러 -> 서비스 -> 리포지터리 순으로 도입

2. ArticleController 클래스 도입
컨트롤러가 다른 곳에서도 사용될 수 있기 때문에 컨테이너에 생성해줌
도입해야 할 mvc구조 - 현재 컨트롤러에서 이루어지는 처리 로직은 서비스에서, 테스트데이터 생성은 리포지터리에서 
```java
public class Container {
  public static Scanner sc;
  public static ArticleController articleController;

  static {
    sc = new Scanner(System.in);
    articleController = new ArticleController();
  }
}
```
```java
public class App {
  public ArticleController articleController;

  public App() {
    // 컨테이너 안에서 만들어진 컨트롤러 불러옴
    articleController = Container.articleController;
  }

  // 우리 로직의 시작점
  void run() {
    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      System.out.print("명령) ");
      String cmd = Container.sc.nextLine();

      Rq rq = new Rq(cmd);

      if (rq.getUrlPath().equals("/usr/article/write")) {
        articleController.doWrite(); // 메서드 이름 행위 = 동사로 수정
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        articleController.showList(rq);
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        articleController.showDetail(rq);
      } else if (rq.getUrlPath().equals("/usr/article/modify")) {
        articleController.doModify(rq);
      } else if (rq.getUrlPath().equals("/usr/article/delete")) {
        articleController.doDelete(rq);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못 된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    Container.sc.close();
  }
}
```
Article 클래스의 위치 article 패키지 안으로
```java
public class ArticleController { // 위치 /../article/ArticleController.java
  private List<Article> articles; // private로 잠궈줘야
  private int lastArticleId;
  public ArticleController() {
    articles = new ArrayList<>();
    lastArticleId = 0;
    makeTestData();
  }
  void makeTestData() {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }
  public void doWrite() {
    lastArticleId = articles.get(articles.size() - 1).id;
    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = Container.sc.nextLine();
    System.out.print("내용 : ");
    String content = Container.sc.nextLine();
    int id = ++lastArticleId;
    Article article = new Article(id, subject, content);
    articles.add(article);
    System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
  } 
  public void showList(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    // 검색 기능 시작
    List<Article> filteredArticls = articles;
    if (params.containsKey("searchKeyword")) {
      String searchKeyword = params.get("searchKeyword");
      filteredArticls = new ArrayList<>();
      for (Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);
        if (matched) filteredArticls.add(article);
      }
    }
    // 검색 기능 끝
    // 정렬 로직 시작
    boolean orderByIdDesc = true;
    if (params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) {
      orderByIdDesc = false;
    }
    List<Article> sortedArticles = filteredArticls;
    if (orderByIdDesc) {
      sortedArticles = Util.reverseList(sortedArticles);
    }
    // 정렬 로직 끝
    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");
    sortedArticles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }
  public void showDetail(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }
    Article article = finById(articles, id);
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }
  public void doModify(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }
    Article article = finById(articles, id);
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    System.out.print("새 제목 : ");
    article.subject = Container.sc.nextLine();
    System.out.print("새 내용 : ");
    article.content = Container.sc.nextLine();
    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }
  public void doDelete(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }
    Article article = finById(articles, id);
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    articles.remove(article);
    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }
  private Article finById(List<Article> articles, int id) {
    return articles.stream()
        .filter(article -> article.id == id)
        .findFirst() // 첫 번째 요소 찾기
        .orElse(null);
  }
}
```
---
3. Rq.getIntParam 메소드 개요

이 코드는 detail 코드에서 파라미터값을 가져오는 코드인데 너무 길다.
/usr/article/detail?id=1 중 1을 가져오는 코드.

`rq.getParams`를 통해 파라미터를 가져오도록 수정
- `rq.getParams`는 파라미터 여러 개를 가져옴
- `rq.getParams("id")`는 파라미터 중에 id만 달라는 것
- `int id = rq.getIntParams("id", 0)`는 정수로 형변환해서 가져와달라는 것
  - id가 존재하지 않는 경우 defaultValue로 0을 줘라
  - id(id == 0) {} 처리만 해주면 됨
```
// detail 코드 중 일부
Map<String, String> params = rq.getParams();
    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }
```
---
4. rq.getIntParam, rq.getParam 을 도입하여 소스코드 다이어트

```java
public class Rq {
  public String url;
  public Map<String, String> params;
  public String urlPath;
  
  public Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }
  
  public Map<String, String> getParams() {
    return params;
  }
  public String getUrlPath() {
    return urlPath;
  }
  
  // rq.getIntParam, getParam 도입
  // paramName 문자열이기 때문에 정수화해줘야
  // 값이 안 들어왔거나 정수가 아니거나의 처리를 해줘야 함
  public int getIntParam(String paramName, int defaultValue) {
    if(!params.containsKey(paramName)) { // 있는지 확인
      return defaultValue; // 없으면 defaultValue
    }
    try {
      return Integer.parseInt(params.get(paramName));
    } catch (NumberFormatException e) {
      return defaultValue;
    }
  }
  public String getParam(String paramName, String defaultValue) {
    if(!params.containsKey(paramName)) {
      return defaultValue;
    }
    return params.get(paramName);
  }
}
```
```java
public class ArticleController {
  private List<Article> articles;
  private int lastArticleId;

  public ArticleController() {
    articles = new ArrayList<>();
    lastArticleId = 0;

    makeTestData();
  }

  void makeTestData() {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }

  public void doWrite() {
    lastArticleId = articles.get(articles.size() - 1).id;

    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = Container.sc.nextLine();

    System.out.print("내용 : ");
    String content = Container.sc.nextLine();

    int id = ++lastArticleId;

    Article article = new Article(id, subject, content);

    articles.add(article);

    System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
  }

  public void showList(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    // 검색 기능 시작
    List<Article> filteredArticls = articles;
    // 4. rq.getParam 을 도입하여 소스코드 다이어트
    String searchKeyword = rq.getParam("searchKeyword", "");

    if (!searchKeyword.isEmpty()) { // 비어있지 않으면 데이터가 들어와있다는 것
      filteredArticls = new ArrayList<>();

      for (Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);

        if (matched) filteredArticls.add(article);
      }
    }
    // 검색 기능 끝

    // 정렬 로직 시작 - rq.getParam으로 수정됨
    String orderBy = rq.getParam("orderBy", "idDesc");
    boolean orderByIdDesc = orderBy.equals("idDesc");

    List<Article> sortedArticles = filteredArticls;

    if (orderByIdDesc) {
      sortedArticles = Util.reverseList(sortedArticles);
    }
    // 정렬 로직 끝

    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");

    sortedArticles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }

  public void showDetail(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    // 4. rq.getIntParam을 도입하여 소스코드 다이어트
    int id = rq.getIntParam("id", 0);

    if(id == 0) {
      System.out.println("올바른 값을 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }

  public void doModify(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    // 4. rq.getIntParam을 도입하여 소스코드 다이어트
    int id = rq.getIntParam("id", 0);

    if(id == 0) {
      System.out.println("올바른 값을 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.print("새 제목 : ");
    article.subject = Container.sc.nextLine();

    System.out.print("새 내용 : ");
    article.content = Container.sc.nextLine();

    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }

  public void doDelete(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    // 4. rq.getIntParam을 도입하여 소스코드 다이어트
    int id = rq.getIntParam("id", 0);

    if(id == 0) {
      System.out.println("올바른 값을 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    articles.remove(article);

    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }

  private Article finById(List<Article> articles, int id) {
    return articles.stream()
        .filter(article -> article.id == id)
        .findFirst() // 첫 번째 요소 찾기
        .orElse(null);
  }
}
```


































