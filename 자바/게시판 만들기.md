### 자바 텍스트 게시판 구현하기

[수업자료](https://www.slog.gg/p/13829)
[수업링크](https://www.youtube.com/watch?v=PngsADCv2xk&feature=youtu.be)

---

### 0. 공부 시작 전 숙지 사항
- 내가 무엇을 할 것인지 파악해야 함
```
게시물 리스트 정렬 구현
/usr/article/list?orderBy=idDesc -> 내림차순 정렬
/usr/article/list?orderBy=idAsc -> 오름차순 정렬

0. boolean orderByIdDesc 값을 만든다.
 - boolean orderByIdDesc = true;
1. params에 orderBy 값이 있는지 체크
 - params.containsKey("orderBy")
2. orderBy가 있다면 그 값이 idAsc인지 체크
 - params.get("orderBy").equals("idAsc")
3. 참이라면 게시물 리스트를 정순으로 출력
 - orderByIdDesc = false로 변경
4. orderBy 값에 따라서 역순순회, 정순순회
```

### 1. 프로젝트 github 푸시
```
git init -- 로컬 저장소 생성
git remote add origin  "원격 저장소 주소"
git config --global user.name "계정 아이디"
git config --global user.email "계정 이메일"
git add . --> 로컬 저장소에 프로젝트 업로드
git commit -m "세팅" --> 업데이트 된 프로젝트 기록 남김
git push origin master(main) --> 원격저장소에 프로젝트 업로드
```

### 2. 게시판 시작과 종료, 기본 기능
**기본 기능**
1. exit 명령이 나올 때 까지 계속 입력받기
2. /usr/article/write 라고 입력하면 게시물 제목, 내용 입력받기
3. 생성된 게시물 정보를 Article 클래스의 객체로 저장 후 문장으로 출력
4. toString 메서드를 오버라이드 하여 Article 객체가 문장으로 출력될 때, 좀 더 설명적으로 나오도록
5. 생성자를 이용해서 게시물 객체를 쉽게 만들기
6. /usr/article/detail 이라고 입력하면, 가장 마지막에 입력받은 게시물의 상세정보 출력
7. /usr/article/list 로 입력하면 게시물리스트 출력, 시작
8. 테스트 게시물 생성 함수 적용
9. 게시물 리스트에서 출력을 최신순으로
10. 게시물 등록시, 마지막 게시물 번호 이후로 id 정하기 
11. lastArticle 변수의 필요성을 제거

src/../text_board/Main.java
```java
public class Main {
  // 8. 테스트 게시물 생성 함수 적용
  static void makeTestData(List<Article> articles) {
    // main이 static이기 때문에 호출되려면 메서드도 static이어야 함
    // static은 프로그램 실행되자마자 제일 먼저 로딩
    articles.add(new Article(1, "제목1", "내용1"));
    articles.add(new Article(2, "제목2", "내용2"));
    articles.add(new Article(3, "제목3", "내용3")); // 인덱스 번호 2, id는 3
  }
  
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    List<Article> articles = new ArrayList<>();
    makeTestData(articles); // articles에 게시물 데이터가 아니라 리스트 객체 주소값이 공유됨
    // 매개변수로 articles를 넘겨줌 -> makeTestData(List<Article> articles)
    // 매개변수로 10을 넘겨줌 makeTestData(10); -> makeTestData(int id)

    // 10. 게시물 등록시, 마지막 게시물 번호 이후로 id 정하기
    int lastArticleId = articles.get(articles.size() -1).id; // articles의 크기의 -1 값(2)의 인덱스의 id인 번호(3)를 articles에서 get 가져온다
    // int lastArticleId = 0;으로 세팅을 해줬었던 기존 코드는 테스트게시물 이후 새 게시물 작성하면 1번으로 작성됨
    // makeTestData가 만들어지고 나서 lastArticleId가 3으로 세팅되어햐 함으로 코드 실행 순서가 makeTestData 다음
    // 코드의 순서를 잘 지켜주는 것도 중요
    
    System.out.println("== 자바 텍스트 게시판 시작 ==");
    while(true) {
      System.out.println("명령) ");
      String cmd = sc.nextLine();

      if (cmd.equals("/usr/article/write")) { // 2. /usr/article/write 라고 입력하면 게시물 제목, 내용 입력받기
        System.out.println("== 게시물 작성 ==");
        System.out.println("제목 : ");
        String subject = sc.nextLine();
        System.out.println("내용 : ");
        String content = sc.nextLine();

        // 3. 생성된 게시물 정보를 Article 클래스의 객체로 저장 후 문장으로 출력
        int id = ++lastArticleId;
        // 이 코드로는 게시물이 저장되지 않음 -> articles.add(article); 로 게시물을 리스트에 저장
        Article article = new Article(id, subject, content); // 5. 생성자를 이용해서 게시물 객체를 쉽게 만들기
        lastArticle = article;

        articles.add(article); // 리스트에 저장

        // 4. toString 메서드를 오버라이드 하여 Article 객체가 문장으로 출력될 때, 좀 더 설명적으로 나오도록
        System.out.println("생성된 게시물 객체: " + article.toString());
        System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);      
      }
      // 7. /usr/article/list 로 입력하면 게시물리스트 출력, 시작
      else if (cmd.equals("/usr/article/list")) {
        if(articles.isEmpty()) {
          System.out.println("현재 게시물이 존재하지 않습니다.");
          continue;
        }

        System.out.println("== 게시물 리스트 ==");

        System.out.println("번호 | 제목");

        // 9. 게시물 리스트에서 출력을 최신순으로
        for (int i = articles.size() - 1; i >= 0; i--) { // articles.size() - 1: 인덱스는 0부터 시작
          Article article = articles.get(i);
          System.out.printf("%d | %s\n", article.id, article.subject);
        }
      }
      // 6. /usr/article/detail 이라고 입력하면, 가장 마지막에 입력받은 게시물의 상세정보 출력
      else if (cmd.equals("/usr/article/detail")) {
        if(articles.isEmpty()) { // 게시물이 하나도 없는 경우
          System.out.println("게시물이 존재하지 않습니다.");
          continue;
        }

        // 11. lastArticle 변수의 필요성을 제거
        Article article =  articles.get(articles.size() -1); // lastArticle 변수 대신 articles의 인덱스를 활용

        // article에는 articles.get(articles.size() -1)의 주소값이 들어가고
        if(article == null) { // 그 주소값이 null이면. 마지막 번호로 접근했는데 그 게시물이 없는 경우
          System.out.println("해당 게시물이 존재하지 않습니다.");
          continue;
        }
        System.out.println("== 게시물 상세보기 ==");
        System.out.printf("번호 : %d\n", article.id);
        System.out.printf("제목 : %s\n", article.subject);
        System.out.printf("내용 : %s\n", article.content);
      } else if (cmd.equals("exit")) { // 1. exit 명령이 나올 때 까지 계속 입력받기
        System.out.println("프로그램을 종료합니다.");
        break; // 반복문 빠져나옴
      }
      else {
        System.out.println("잘못된 명령어입니다.");
      }
    }
    System.out.println("== 자바 텍스트 게시판 종료 ==");
    sc.close();
  }
}
class Article {
  int id;
  String subject;
  String content;

  // 5. 생성자를 이용해서 게시물 객체를 쉽게 만들기
  public Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }

  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}
```
---
### 2. URL 파라미터 개념
1. String.split 메소드를 이용해서 큰 문장을 작은 문장들로 나누기
2. String.split 메소드를 여러번 사용해서 조금 더 세밀한 정보를 얻어내기
3. Integer.parseInt 를 사용해서 문장을 정수화 하기
4. 리스트 2개를 사용하여, 파라미터 이름들과 값들을 따로 담기
5. 쿼리스트링을 리스트를 이용하여 관리할 때 불편한점 설명
6. 쿼리스트링을 분석하여 분리한 데이터를 Map에 저장
7. 파싱로직을 매번 복붙해서 사용하는 비효율을 제거하기 위해 Util.getParms 메서드 도입
8. Util.getParamsFromUrl 를 오류 기반으로 문제 해결, 구조 및 개선
9. url로 부터 urlPath 부분만 가져오기
10. Util을 직접 이용하는 것보다 더 좋은 방법 설명
11. Rq가 Util한테 일을 최대한 적게 시키도록 구조개선
12. if문을 사용하지 않고 Rq가 Util을 사용하도록 구조 개선
---
1. String.split 메소드를 이용해서 큰 문장을 작은 문장들로 나누기

이 링크를 가지고 쿼리 파라미터를 알아보자. 도메인+ URL Path+쿼리 파라미터로 이루어져 있다.
[https://search.naver.com/search.naver?ie=UTF-8&sm=whl_hty&query=사과](https://search.naver.com/search.naver?ie=UTF-8&sm=whl_hty&query=%EC%82%AC%EA%B3%BC)

- [search.naver.com](https://search.naver.com) ← 도메인
- search.naver ← URL Path
- [ie=UTF-8&sm=whl_hty&query=사과](https://search.naver.com/search.naver?ie=UTF-8&sm=whl_hty&query=%EC%82%AC%EA%B3%BC) ← 쿼리 파라미터

**쿼리 파라미터란?**

- 파라미터 이름=파라미터값
- String 문자열에는 split(”기준”)이 있음
    - ex. split(”&”) ← &을 기준으로 쪼갠다

String queryString = "a=1&b=2&c=3";
- a=1, b=2, c=3으로 쪼개고 싶다
- 쪼개면 a=1&b=2&c=3 문장 하나가 아니라 3개의 a=1, b=2, c=3 ***문장들이 되어버림***

***즉, 배열에 담아야 한다.***

위치: /../test/java/AppTest.java
```java
public class AppTest {
	public static void main(String[] args) {
		// 파라미터 분석
		String queryString = "a=1&b=2&c=3";
		// a=1, b=2, c=3으로 쪼개고 싶다
		String[] queryStringBits = queryString.split("&");
		// 문장들을 배열에 담는다
	}
}
```
---
2. String.split 메소드를 여러번 사용해서 조금 더 세밀한 정보를 얻어내기

- a=1 ← 각각이 하나의 쿼리 스트링
- b=2 ← b가 파라미터 name
- c=3 ← 3이 파라미터 value

***“=”을 기준으로 쪼갠다***

- [a, 1] ← 0번째가 파라미터 name
- [b, 2] ← 1번째가 파라미터 value
- [c, 3]

```java
public class AppTest {
	public static void main(String[] args) {
		// 파라미터 분석
		String queryString = "a=1&b=2&c=3";
		// a=1, b=2, c=3으로 쪼개고 싶다
		String[] queryStringBits = queryString.split("&");
		// 문장들을 배열에 담는다
		
		for(String bit : queryStringBits) {
      String[] bitBits = bit.split("=");
      String paramName = bitBits[0];
      String paramValue = bitBits[1];
    }
  }
}
```
---
3. Integer.parseInt 를 사용해서 문장을 정수화 하기

- a=1, b=2, c=3을 특정 변수에 담고 싶다
- paramValue는 문자열인데 ***Integer.parseInt***를 붙이면 정수로 변환해줌

```java
public class AppTest {
	public static void main(String[] args) {
		// 파라미터 분석
		String queryString = "a=1&b=2&c=3";
		// a=1, b=2, c=3으로 쪼개고 싶다
		String[] queryStringBits = queryString.split("&");
		// 문장들을 배열에 담는다
		
		int a = 0;
		int b = 0;
		int c = 0;	
		
		for(String bit : queryStringBits) {
			String[] bitBits = bit.split("=");
			String paramName = bitBits[0];
			String paramValue = bitBits[1];
			
			if(paramName.equals("a")) {
				a = Integer.parseInt(paramValue);
			} else if(paramName.equals("b")) {
				b = Integer.parseInt(paramValue);
			} else {
				c = Integer.parseInt(paramValue);
			}
		}
	}
}
```
---
4. 리스트 2개를 사용하여, 파라미터 이름들과 값들을 따로 담기

"a=1&b=2&c=3" → "a=1&b=2&c=3&d=4"

***파라미터에 새로운 값이 추가된 경우 변수와 조건문을 계속 추가해주는 것은 비효율적!***

- 코드가 변했을 때 계속 수정해주는 것은 유연하지 못한 코드 ← 안 좋은 코드
- 값을 관리하는 두 개의 공간을 만든다
- 단, 배열로 만들면 사이즈가 정해져 있기 때문에 List로 담기

paramName : [a, b, c, d]

paramValue : [1, 2, 3, 4]

→ "c=1&b=2&a=3" 순서가 바뀌어도 ok.

→ "a=1&b=2&c=3&d=4" 값이 추가되어도 ok.

```java
public class AppTest {
	public static void main(String[] args) {
		// 파라미터 분석
		String queryString = "a=1&b=2&c=3";
		// a=1, b=2, c=3으로 쪼개고 싶다
		String[] queryStringBits = queryString.split("&");
		// 문장들을 배열에 담는다
		
		List<String> paramNames = new ArrayList<>();
		List<Integer> paramValues = new ArrayList<>();
		
		for(String bit : queryStringBits) {
			String[] bitBits = bit.split("=");
			String paramName = bitBits[0];
			String paramValue = bitBits[1];

		paramNames.add(paramName);
		paramValues.add(Integer.parseInt(paramValue));
		
		for(int i = 0; i < paramNames.size(); i++) {
			String paramName = paramNames.get(i);
			int paramValue = paramValues.get(i);
			}
		}
	}
}
```
---
5. 쿼리스트링을 리스트를 이용하여 관리할 때 불편한점 설명

name과 value를 따로 저장하고 있기 때문에 그 저장된 값을 매칭시키면서 봐줘야 한다.

ex. 동아리 명부와 전화번호를 두 개의 엑셀 파일로 만들어 저장해두면 회원명과 전화번호를 각각의 파일에서 매칭시켜 번갈아 보며 확인해야됨

게시물 수정할 때,
- id=20&subject=자바수업&content=내용&writerName=김철수
- 이런 데이터가 들어왔을 때 paramNames의 content와 paramValues의 내용을 일치시키기 위해 그 위치를 알아야 한다

- ***int findIndex = paramNames.indexOf(”content”); ← 위치 파악***
- ***paramValues.get(findIndex) ← 파악된 위치의 값을 가져옴***

→ 매번 name과 value를 일치시키는 불편함이 존재한다!

```java
public class AppTest {
	public static void main(String[] args) {
		String queryString = "id=20&subject=자바수업&content=내용&writerName=김철수";
		String[] queryStringBits = queryString.split("&");
		
		List<String> paramNames = new ArrayList<>();
		List<String> paramValues = new ArrayList<>();
		
		for(String bit : queryStringBits) {
			String[] bitBits = bit.split("=");
			String paramName = bitBits[0];
			String paramValue = bitBits[1];

		paramNames.add(paramName);
		paramValues.add(Integer.parseInt(paramValue));
		
		int findIndex = paramNames.indexOf("content");
		System.out.println(paramValues.get(findIndex));
		}
	}
}
```
---
6. 쿼리스트링을 분석하여 분리한 데이터를 Map에 저장

위 어려움을 개선하는 방법: ***Map*** 도입

Map<String, String> ← 둘 다 문자열을 받는다

- 첫 번째 key값 String은 고정!

HashMap은 순서를 보장하지 않기 때문에 내용을 출력해서 보면 뒤죽박죽

- 어차피 key를 확인해서 data에 접근할 수 있기 때문
- LinkedHashMap은 순서 보장

```java
public class AppTest {
	public static void main(String[] args) {
		String queryString = "id=20&subject=자바수업&content=내용&writerName=김철수";
		String[] queryStringBits = queryString.split("&");
		
		Map<String, String> params = new LinkedHashMap<>();
		
		for(String bit : queryStringBits) {
			String[] bitBits = bit.split("=");
			params.put(bitBits[0], bitBits[1]);
		}
		
		System.out.println("==반복문을 사용하여 순회 출력==");
		for(String paramName : params.keySet()) {
			String paramValue = params.get(paramName);
			System.out.printf("%s : %s\n", paramName, paramValue);
		}
	}
}
```
---
7. 파싱로직을 매번 복붙해서 사용하는 비효율을 제거하기 위해 Util.getParms 메서드 도입

쿼리스트링을 2개 이상 분석해야 하는 경우
- 반복적으로 사용하는 코드의 경우 객체지향적으로 처리하는 것이 좋다
  - [기존의 쿼리스트링+분석 클래스]를 쿼리 스트링만 준비하는 클래스와 별도로 분석하는 클래스로 나눈다
    - 쿼리 스트링을 별도로 분석하는 클래스: `Util`

Map<String, String> params1 = Util.getParams(queryString1);
- 위 코드를 만들고 Util 클래스를 만든다
- Util.getParams 메서드는 인자값 String queryStr을 받아 Map<String, String> 타입이기 때문에
- Util 클래스에서 getParams 메서드를 정의할 때 static Map<String, String> getParams(String queryStr) {
- 


```java
public class AppTest {
  public static void main(String[] args) {
    // 파라미터 분석
    String queryString1 = "id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=20";
    Map<String, String> params1 = Util.getParams(queryString1);
    System.out.println(params1);

    String queryString2 = "id=20&subject=자바&content=내용2&writerName=김수정&hitCount=40";
    Map<String, String> params2 = Util.getParams(queryString2);
    System.out.println(params2);

  }
}

class Util {
  // 메인 메서드가 static이기 때문에 Util을 객체화하지 않고 사용할 수 있는 static 클래스로 만들기
  static Map<String, String> getParams(String queryStr) {
    Map<String, String> params = new LinkedHashMap<>();
    String[] queryStrBits = queryStr.split("&");

    for(String bit : queryStrBits) {
      String[] bitBits = bit.split("=");

      params.put(bitBits[0], bitBits[1]); // 0번째 key, 1번째 value
    }
    return params;
  }
}
```

---
8. Util.getParamsFromUrl 를 오류 기반으로 문제 해결, 구조 및 개선: Util.getParamsFromUrl 구현


   1. `?` 기준으로 앞 뒤를 나눈다.
   2. 배열의 index 1번째 값을 가져와서 `&`를 기준으로 쪼갠다.
   3. 2번의 결과를 `=`을 기준으로 쪼갠다.
   4. 2 ~ 3번을 한 결과를 map의 담는다.
   - index 0, key
   - index 1, value
   5. 담은 결과를 리턴하여 해당 결과를 출력한다.


```java
public class AppTest {
  public static void main(String[] args) {
    // 파라미터 분석
    String url = "/usr/article/write?id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30";
    Map<String, String> params = Util.getParamsFromUrl(url);
    System.out.println(params);

    System.out.println(params.get("id")); // 20
    System.out.println(params.get("subject")); // 자바수업
    System.out.println(params.get("content")); // 내용
    System.out.println(params.get("writerName")); // 김철수
    System.out.println(params.get("hitCount")); // 30
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2); // 특수문자(?과 같은)를 split으로 나눌 때 \\? 붙여줌
    // 쪼개기만 하면 배열 객체 주소가 나오며 2의 의미는 ?를 기준으로 2등분으로 쪼개주라는 뜻
    // ?가 3개일 경우 2를 통해 2개로 쪼갤 수 있다. 2는 limit값

    if(urlBits.length == 1) { // 길이가 1개라는 것은 쪼개지지 않았음을 의미
      return params;
    }

    String queryStr = urlBits[1]; // id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2); // =을 기준으로 쪼개는데 2개 이상으로 쪼개지 않겠다
      // ex. id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30&cals=[10+20=]
      // limit 2를 하지 않으면 `cals=[10+20=]`은 `[10+20`으로 쪼개짐
      // limit 2를 해주면 `[10+20=]`으로 쪼개진다

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }
}
```

---
9. url로 부터 urlPath 부분만 가져오기

/usr/article/write < urlPath

```java
public class AppTest {
  public static void main(String[] args) {
    // 파라미터 분석
    String url = "/usr/article/write?id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30";
    Map<String, String> params = Util.getParamsFromUrl(url);
    System.out.println(params);

    // String urlPath: String으로 받겠다고 했으니 
    String urlPath = Util.getPathFromUrl(url);
    System.out.println(urlPath);

  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  // 리턴 타입을 String으로 만들어야 함
  static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0]; // /usr/article/write
  }
}
```
---
10. Util을 직접 이용하는 것보다 더 좋은 방법 설명

/usr/article/write?id=20&subject=자바수업&content=내용

지금까지의 Util

    1. URL Path을 가져오는 역할
        - /usr/article/write
    2. 쿼리 스트링을 분석해서 파라미터를 찾아내는 역할
        - id=20&subject=자바수업&content=내용

개선

- Rq를 도입하여 Rq가 중간다리 역할을 해주도록 구현
- Util을 모르더라도 Rq를 이용해서 Rq가 Util에 요청 
  - URL Path을 가져오고 파라미터를 가져오도록

현재 Rq의 문제점

- A(부장), B(나), C만 발급할 수 있는 문서
- A(문서 발급 요청) -> B
- B(문서 발급 요청) -> C
- C(문서 발급 완료) -> B
- B(발급된 문서 전달) -> A
- A(문서 발급 재요청) -> B
- A의 요청으로 B가 C에 계속 왔다갔다 하는 것은 비효율적!

개선

- B가 C의 문서를 기억하고 있다면?
- B가 기억한 문서를 A에게 전달 가능!

```java
public class AppTest {
  public static void main(String[] args) {
    // Rq가 url을 품고 태어나려면 생성자 메서드가 있어야 함
    Rq rq = new Rq("/usr/article/write?id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30");
    Map<String, String> params = rq.getParams();
    System.out.println(params);
    System.out.println(rq.getParams());
    System.out.println(rq.getParams());

    String urlPath = rq.getUrlPath();
    System.out.println(urlPath);
    System.out.println(rq.getUrlPath());
    System.out.println(rq.getUrlPath());
  }
}

class Rq {
  String url;

  Rq(String url) { // 생성자 메서드로 url 받아올 수 있도록
    this.url = url;
  }

  public Map<String, String> getParams() { // Util에게 요청함
    return Util.getParamsFromUrl(url);
  }

  public String getUrlPath() { // Util에게 요청함
    return Util.getPathFromUrl(url);
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    System.out.println("getParamsFromUrl 실행!!"); // 실행 메시지가 매번 출력됨 = 요청할 때마다 계속 방문
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    System.out.println("getPathFromUrl 실행!!");
    return url.split("\\?", 2)[0];
  }
}
```
---
11. Rq가 Util한테 일을 최대한 적게 시키도록 구조개선

Rq는 객체가 만들어지자마자 url을 기억한다

```java
public class AppTest {
  public static void main(String[] args) {
    Rq rq = new Rq("/usr/article/write?id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30");
    // Rq는 객체가 만들어지자마자 url을 기억한다
    Map<String, String> params = rq.getParams(); // 첫 요청 - 이때 rq가 util 한 번 방문하고 그 이후엔 기억한 내용 보여줌.
    System.out.println(params);
    System.out.println(rq.getParams());
    System.out.println(rq.getParams());

    String urlPath = rq.getUrlPath();
    System.out.println(urlPath);
    System.out.println(rq.getUrlPath());
    System.out.println(rq.getUrlPath());
  }
}

class Rq {
  String url;
  // rq가 만들어지자마자 최초의 params와 urlPath는 비어있는 상태
  Map<String, String> params; 
  String urlPath;

  Rq(String url) {
    this.url = url; // 객체가 태어나자마자 url을 저장
  }

  public Map<String, String> getParams() {
    if(params == null) { // 최초의 상태가 null. null이면 데이터를 채워줘야
      params = Util.getParamsFromUrl(url); // util에 한 번 다녀와서 url을 기억한다
    }

    return params; // 두 번째 요청이 들어왔을 때는 params가 null이 아니므로 기억한 params를 줄 수 있음
  }

  public String getUrlPath() {
    if(urlPath == null) {
      urlPath = Util.getPathFromUrl(url);
    }

    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    System.out.println("getParamsFromUrl 실행!!"); // rq가 기억한 뒤로 실행 메시지가 한 번만 나오게 됨
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    System.out.println("getPathFromUrl 실행!!");
    return url.split("\\?", 2)[0];
  }
}
```
---
12. if문을 사용하지 않고 Rq가 Util을 사용하도록 구조 개선

생성자 메서드를 통해
조건문을 사용하지 않고 
rq가 params, urlPath를 기억하도록 개선

```java
public class AppTest {
  public static void main(String[] args) {
    Rq rq = new Rq("/usr/article/write?id=20&subject=자바수업&content=내용&writerName=김철수&hitCount=30");
    Map<String, String> params = rq.getParams();
    System.out.println(params);
    System.out.println(rq.getParams());
    System.out.println(rq.getParams());

    String urlPath = rq.getUrlPath();
    System.out.println(urlPath);
    System.out.println(rq.getUrlPath());
    System.out.println(rq.getUrlPath());
  }
}

class Rq {
  String url;
  Map<String, String> params;
  String urlPath;

  // 생성자 메서드가 제일 먼저 실행되기 때문에 실행 메시지가 위로 올라감
  Rq(String url) { // 조건문을 사용하지 않고 rq가 params, urlPath를 기억함
    this.url = url;
    params = Util.getParamsFromUrl(this.url); // 객체가 생성되자마자
    urlPath = Util.getPathFromUrl(this.url); // 데이터가 알아서 들어간다
    // url은 String url을 뜻하고, url이 아닌 this.url을 넘겨주는 것이 좋다
  }

  public Map<String, String> getParams() {
    return params;
  }

  public String getUrlPath() {
    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    System.out.println("getParamsFromUrl 실행!!");
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    System.out.println("getPathFromUrl 실행!!");
    return url.split("\\?", 2)[0];
  }
}
```
---
### 3. URL 파라미터 분석 실습
35-39강까지

1. 복잡한 명령어를 처리하기 위해, Rq 도입
2. Rq도입하여 게시물 상세보기 시에, 원하는 게시물 번호 입력
3. 입력된 id에 대해서 유효성 체크
4. orderBy=idDesc 파라미터에 의한 정렬방법 변경
5. Util.reverseList 를 이용해서 정렬로직 간소화
---

```java
public class Main {
  static void makeTestData(List<Article> articles) {
    articles.add(new Article(1, "제목1", "내용1"));
    articles.add(new Article(2, "제목2", "내용2"));
    articles.add(new Article(3, "제목3", "내용3"));
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    List<Article> articles = new ArrayList<>();

    makeTestData(articles);

    int lastArticleId = articles.get(articles.size() - 1).id;

    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      System.out.print("명령) ");
      String cmd = sc.nextLine();

      // 1. 복잡한 명령어를 처리하기 위해, Rq 도입
      Rq rq = new Rq(cmd); // rq 도입부분. cmd가 url임

      if (rq.getUrlPath().equals("/usr/article/write")) {
        System.out.println("== 게시물 작성 ==");
        System.out.print("제목 : ");
        String subject = sc.nextLine();

        System.out.print("내용 : ");
        String content = sc.nextLine();

        int id = ++lastArticleId;

        Article article = new Article(id, subject, content);

        articles.add(article);

        System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        if(articles.isEmpty()) {
          System.out.println("현재 게시물이 존재하지 않습니다.");
          continue;
        }
        
        // 4. orderBy=idDesc 파라미터에 의한 정렬방법 변경
        // /usr/article/list?orderBy=idDesc -> 내림차순 정렬
        // /usr/article/list?orderBy=idAsc -> 오름차순 정렬
        Map<String, String> params = rq.getParams(); // params를 가져옴
        boolean orderByIdDesc = true; // 4-1. boolean orderByIdDesc 값을 만든다. -> true이면 역순정렬
        if(params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) { // 4-2. params에 orderBy 값이 있는지 체크
          // orderBy가 있다면 그 값이 idAsc인지 체크
          orderByIdDesc = false; // 4-2. 참이라면 게시물 리스트를 정순으로 출력
          // Collections.reverse(articles); 를 사용하지 않는 이유: 원본 리스트 값을 뒤집어 원본 훼손
        }

        System.out.println("== 게시물 리스트 ==");

        System.out.println("번호 | 제목");
        
        // 5. Util.reverseList 를 이용해서 정렬로직 간소화
        List<Article> sortedArticles = articles; // articles는 정렬되지 않는 순수한 로직을 담고 있음 

        // 4-3. orderBy 값에 따라서 역순순회, 정순순회
        if(orderByIdDesc) { // 역순정렬
          sortedArticles = Util.reverseList(sortedArticles);
        }
        sortedArticles.forEach(
            article -> System.out.printf("%d | %s\n", article.id, article.subject)
        );

        // 2. Rq도입하여 게시물 상세보기 시에, 원하는 게시물 번호 입력
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        if(articles.isEmpty()) {
          System.out.println("현재 게시물이 존재하지 않습니다.");
          continue;
        }

        // /usr/aritcle/detail?id=1
        // rq의 2가지 기능: urlPath(/usr/aritcle/detail), urlParams(id=1)
        Map<String, String> params = rq.getParams(); // urlParams(id, 1)(key, value)을 가져오는 역할
        // int id = Integer.parseInt(params.get("id")); // Map에서 저장한 타입이 String이기 때문에 "id" -> 정수화

        // 3. 입력된 id에 대해서 유효성 체크
        if(!params.containsKey("id")) { // containsKey: 해당 키로 접근했을 때 Map 안에서 있는지 확인함. 있으면 true
          System.out.println("id 값을 입력해주세요."); // containsKey가 false의 경우
          continue;
        }
        int id = 0; // 지역변수 id 세팅
        try {
          id = Integer.parseInt(params.get("id")); // try-catch 안의 id가 지역변수이기 때문에
        } catch (NumberFormatException e) { // 예외처리를 해줘야 오류 발생시 터지지 않음
          System.out.println("id를 정수형태로 입력해주세요.");
          continue;
        }
        
        // Article article = articles.get(id); 가 안 되는 이유
        // /usr/article/detail?id=1 했을 때 인덱스 1번 게시물의 번호는 2 
        
        // 유효성 검사가 잘 이루어져야
        if(id > articles.size()) {
          System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
          continue;
        }

        // IndexOutOfBoundsException이 나올 것을 방지하기 위해
        // if(id > articles.size()) { 아래에 배치
        Article article = articles.get(id - 1);

        System.out.println("== 게시물 상세보기 ==");
        System.out.printf("번호 : %d\n", article.id);
        System.out.printf("제목 : %s\n", article.subject);
        System.out.printf("내용 : %s\n", article.content);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못 된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    sc.close();
  }
}

class Article {
  int id;
  String subject;
  String content;

  Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }

  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}

class Rq {
  String url;
  Map<String, String> params;
  String urlPath;

  Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }

  public Map<String, String> getParams() {
    return params;
  }

  public String getUrlPath() {
    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0];
  }

  // 이 함수는 원본리스트를 훼손하지 않고, 새 리스트를 만듭니다. 즉 정렬이 반대인 복사본리스트를 만들어서 반환합니다.
  // 제너릭 타입 <T>
  // 새로운 리스트를 다시 만들어서 그 리스트를 뒤짚어줌
  public static<T> List<T> reverseList(List<T> list) {
    List<T> reverse = new ArrayList<>(list.size());
    for ( int i = list.size() - 1; i >= 0; i-- ) {
      reverse.add(list.get(i));
    }
    return reverse;
  }
}
```
---
### 4. SearchKeyword 도입
40~42강
1. 게시물 중 특정키워드에 관련된 것들만 따로 필터링해서 새 리스트에 저장하는 방법
2. 테스트 게시물을 100개로 늘림
3. searchKeyword를 이용한 게시물 검색어 기능 구현
---
1. 게시물 중 특정키워드에 관련된 것들만 따로 필터링해서 새 리스트에 저장하는 방법

테스트 케이스를 만들어 필요한 데이터를 추가한 후 `자바 문자열 포함 여부`등을 검색하여 내용 찾아보고 테스트케이스를 공부할 수 있다.

테스트를 해보지 않고 원본 코드에 바로 도입할 경우 원본 코드가 무너질 수 있으니 테스트 적극 활용할 것!
```java
public class SearchKeywordTest { // 위치 src/test/java/SearchKeywordTest.java
  public static void main(String[] args) {
    List<Article> articles = new ArrayList<>();
    IntStream.rangeClosed(1, 5)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
    
    // 그외 게시물 추가
    articles.add(new Article(6, "자바는 무슨 언어인가요?", "자바는 객체지향 프로그래밍 언어입니다."));
    articles.add(new Article(7, "코딩 실력 빨리 늘려면 어떻게 하나요?", "반복학습이 정답이다."));
    
    // 제목이 포함된 항목 찾기
    String searchKeyword = "제목";
    // 찾은 항목을 담을 리스트
    List<Article> filteredArticles = new ArrayList<>();
    
    // 향상된 for문
    // articles의 0~6번째 article의 subject에서 searchKeyword가 포함된 항목을 찾아 filteredArticles에 저장
    for(Article article : articles) {
      if(article.subject.contains(searchKeyword)) {
        filteredArticles.add(article);
      }
    }
    System.out.println(filteredArticles);
  }
}

// 테스트에 필요한 데이터 추가
class Article {
  int id;
  String subject;
  String content;
  Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }
  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}
```
2. 테스트 게시물을 100개로 늘림
Main클래스의 makeTestData 수정
```java
// 생략
static void makeTestData(List<Article> articles) {
    /*
    for(int i = 1; i <= 100; i++) {
      articles.add(new Article(i, "제목" + i, "내용" + i);
    }
    */
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }
// 생략
```
3. searchKeyword를 이용한 게시물 검색어 기능 구현
```java
public class Main {
  public static void main(String[] args) {
// 생략
    // if가 아니라 `else if`이지만 정리에는 if로 표기함
    if (rq.getUrlPath().equals("/usr/article/list")) { // else if
      if (articles.isEmpty()) {
        System.out.println("현재 게시물이 존재하지 않습니다.");
        continue;
      }

      Map<String, String> params = rq.getParams();
// 검색 기능 시작
// articles : 현재 정렬되지 않은 1 ~ 100개의 게시물 리스트
      List<Article> filteredArticls = articles;

      // searchKeyword가 들어왔는지 확인하는 코드
      if (params.containsKey("searchKeyword")) {
        String searchKeyword = params.get("searchKeyword");
        filteredArticls = new ArrayList<>(); // 초기화를 시켜줌. 새롭게 필터링한 결과를 담아줄 것

        for (Article article : articles) {
          boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);

          if (matched) filteredArticls.add(article);
        }
      }
// 검색 기능 끝

// 정렬 로직 시작
      boolean orderByIdDesc = true;
      if (params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) {
        orderByIdDesc = false;
      }
      // 필터링된 값을 sortedArticles에 공유함으로써 출력될 수 있도록
      // searchKeyword가 입력되지 않으면 searchKeyword를 필터링하는 코드가 실행되지 않고
      // 정렬되지 않은 articles이다
      List<Article> sortedArticles = filteredArticls;

      if (orderByIdDesc) {
        sortedArticles = Util.reverseList(sortedArticles);
      }
      // 정렬 로직 끝
      System.out.println("== 게시물 리스트 ==");
      System.out.println("번호 | 제목");

      sortedArticles.forEach(
          article -> System.out.printf("%d | %s\n", article.id, article.subject)
      );

    }
  }
}
// 생략
```


---
### 5. 메서드로 분리
43~47강
1. 명령어 usr/article/list 에 대한 처리를 별도의 함수로 분리
2. actionUsrArticleDetail 메서드 구현
3. actionUsrArticleWrite 메서드 구현
4. actionUsrArticleModify 메서드 구현
5. 게시물 삭제 기능 구현, findById 메서드 도입

현재 기능
- /usr/article/list
- /usr/article/detail
- /usr/article/write
기능이 추가될수록 코드의 길이는 더 늘어날 것
- 실행코드의 길이를 줄이기 위해 별도의 메서드로 만들어서 처리

게시물 수정 기능 구현
1. actionUsrArticleModify(); 만들기
  /usr/article/modify?id=1 명령을 사용할 수 있도록
2. 유효성 검사 필수
  - `id`파라미터 제대로 입력되었는가
  - 입력되었다면 그 값이 정수인가
  - id에 맞는 게시물이 존재하지 않는 경우
3. 명령어 처리
  - 제목: 수정된 제목
  - 내용: 수정된 내용
  - 1번 게시물이 수정되었습니다.

게시물 삭제 기능 구현
- 리스트에서 0번째를 삭제할 경우 다음 값이 0번째가 됨
- findById 도입
```java
public class Main {
  static void makeTestData(List<Article> articles) {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    List<Article> articles = new ArrayList<>();
    makeTestData(articles);
    int lastArticleId = articles.get(articles.size() - 1).id; // 100
    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      System.out.print("명령) ");
      String cmd = sc.nextLine();

      Rq rq = new Rq(cmd);

      if (rq.getUrlPath().equals("/usr/article/write")) {
        // 3. actionUsrArticleWrite 메서드 구현
        actionUsrArticleWrite(sc, articles, lastArticleId);
        // actionUsrArticleWrite 내부에서 증가시키면 메서드 종료 시 함께 종료되어 증가되지 않음
        lastArticleId++; // 번호 100 이상으로 증가될 수 있도록
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        // 1. 명령어 usr/article/list 에 대한 처리를 별도의 함수로 분리
        actionUsrArticleList(rq, articles); // /list에서 필요한 rq, articles 넘겨주기
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        // 2. actionUsrArticleDetail 메서드 구현
        actionUsrArticleDetail(rq, articles);
      } else if (rq.getUrlPath().equals("/usr/article/modify")) {
        // 4. actionUsrArticleModify 메서드 구현
        actionUsrArticleModify(sc, rq, articles);
      } else if (rq.getUrlPath().equals("/usr/article/delete")) {
        // 5. 게시물 삭제 기능 구현, findById 메서드 도입
        actionUsrArticleDelete(rq, articles);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    sc.close();
  }

  // 5. 게시물 삭제 기능 구현, findById 메서드 도입
  private static void actionUsrArticleDelete(Rq rq, List<Article> articles) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    // 입력한 id와 리스트의 id가 일치하는지 확인해야 함
    // 리스트는 삭제하면 데이터 순서가 땡겨지기 때문에
    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    articles.remove(article);

    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }
  
  // 4. actionUsrArticleModify 메서드 구현
  private static void actionUsrArticleModify(Scanner sc, Rq rq, List<Article> articles) {
    if(articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    if(!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    System.out.print("새 제목 : ");
    article.subject = sc.nextLine();
    System.out.print("새 내용 : ");
    article.content = sc.nextLine();
    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }

  // 3. actionUsrArticleWrite 메서드 구현
  private static void actionUsrArticleWrite(Scanner sc, List<Article> articles, int lastArticleId) {
    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = sc.nextLine();
    System.out.print("내용 : ");
    String content = sc.nextLine();
    int id = ++lastArticleId;
    Article article = new Article(id, subject, content);
    articles.add(article);
    System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
  }

  // 2. actionUsrArticleDetail 메서드 구현
  private static void actionUsrArticleDetail(Rq rq, List<Article> articles) {
    if(articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    if(!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }
    // 만일 1번 게시물이 삭제되었다면 리스트는 순서가 땡겨지기 때문에
    // /usr/article/detail?id=1을 하면 2번 게시물이 보여지게 됨
    // findById 도입
    Article article = finById(articles, id);
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }

  // 1. 명령어 usr/article/list 에 대한 처리를 별도의 함수로 분리
  private static void actionUsrArticleList(Rq rq, List<Article> articles) {
    if(articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      // 함수를 종료시키는 return 사용
      return; // 기존 continue에서 반복문 밖으로 나왔기 때문에 return으로 수정
    }
    Map<String, String> params = rq.getParams();
    // 검색 기능 시작
    List<Article> filteredArticls = articles;
    if(params.containsKey("searchKeyword")) {
      String searchKeyword = params.get("searchKeyword");
      filteredArticls = new ArrayList<>();
      for(Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);
        if(matched) filteredArticls.add(article);
      }
    }
    // 검색 기능 끝
    // 정렬 로직 시작
    boolean orderByIdDesc = true;
    if(params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) {
      orderByIdDesc = false;
    }
    List<Article> sortedArticles = filteredArticls;
    if(orderByIdDesc) {
      sortedArticles = Util.reverseList(sortedArticles);
    }
    // 정렬 로직 끝
    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");
    sortedArticles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }
  // 5. 게시물 삭제 기능 구현, findById 메서드 도입
  private static Article finById(List<Article> articles, int id) {
    /*
    for (Article article : articles) { // articles의 0, 1, 2번째가 article에 들어감
      if (article.id == id) { // article.id와 id(내가 입력한 id)가 일치할 때
        return article;
      }
    }
    */

    return articles.stream()
            .filter(article -> article.id == id)
            .findFirst() // 첫 번째 요소 찾기
            .orElse(null);
  }
}

class Article {
  int id;
  String subject;
  String content;

  Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }

  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}

class Rq {
  String url;
  Map<String, String> params;
  String urlPath;

  Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }

  public Map<String, String> getParams() {
    return params;
  }

  public String getUrlPath() {
    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if(urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for(String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if(bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0];
  }
  // 이 함수는 원본리스트를 훼손하지 않고, 새 리스트를 만듭니다. 즉 정렬이 반대인 복사본리스트를 만들어서 반환합니다.
  public static<T> List<T> reverseList(List<T> list) {
    List<T> reverse = new ArrayList<>(list.size());
    for ( int i = list.size() - 1; i >= 0; i-- ) {
      reverse.add(list.get(i));
    }
    return reverse;
  }
}
```
---
### 6. 리팩토링
48~51강
1. articles, articlesLastId 변수를 static 변수로 전환
2. 스캐너를 공공재로 변경하여, 언제 어디서거든 쉽게 접근하도록
3. App 클래스 도입하여, 불필요했던 static 키워드를 대부분 제거
4. 클래스별 파일 분리
---

매번 rq, articles 등을 넘겨줘야 했음
```
} else if (rq.getUrlPath().equals("/usr/article/detail")) {
    actionUsrArticleDetail(rq, articles);
```

ver1) 변경 전
```
class Main{
  static void main() {
    int a = 10; // main 안에서 만들어진 지역변수
    int b = 20;
    
    int rs1 = plus(a, b); // 매개변수 값으로 a, b를 전달
    int rs2 = minus(a, b); // 지역변수를 메서드에서 쓸 수 없기 때문에 인자 값으로 넘기고 있음
  }
  
  static int plus(int a, int b) {} // static인 main에서 호출되려면 메서드도 static이어야 함
  static int minus(int a, int b) {}

}
```

ver2) 변경 후
```
class Main{
  int a = 10; // 전역변수
  int b = 20;
  
  static void main() {
    int rs1 = plus(); // 전역변수 a,b를 인자 값으로 넘겨줄 필요 없음
    int rs2 = minus();
  }
  
  static int plus() { // 매개변수 값을 받지 않아도
    return a + b; // 가능!
  }
  static int minus() {
    return a - b; // 가능!
  }
}
```
#### 싱글톤패턴

게시판이 커지면 Article, Member, Reply 등에서 모두 스캐너를 사용해야 한다. 매번 스캐너를 열고 닫는 것보다
스캐너를 공공재로 변경해주고 가져와 사용할 수 있도록 수정.

컨테이너를 도입하는 패턴 - 싱글톤 패턴
```java
// 2. 스캐너를 공공재로 변경하여, 언제 어디서거든 쉽게 접근하도록
public class Container { // 위치 text_board.container.Container.java
  public static Scanner sc;
  static { // 컨테이너를 객체화하지 않고 가져올 수 있도록 static으로 만듦
    sc = new Scanner(System.in);
  }
}
```



```java
// 2. 스캐너를 공공재로 변경하여, 언제 어디서거든 쉽게 접근하도록
import com.sbs.java.text_board.container.Container;

public class Main {
  // 1. articles, articlesLastId 변수를 static 변수로 전환
  // static 메서드는 static만 접근 가능하여 static으로 만들어줌
  static List<Article> articles = new ArrayList<>();
  static int lastArticleId = 0;
  static void makeTestData() {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }

  public static void main(String[] args) {
    makeTestData();

    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      System.out.print("명령) ");
      String cmd = Container.sc.nextLine();

      Rq rq = new Rq(cmd);

      if (rq.getUrlPath().equals("/usr/article/write")) {
        actionUsrArticleWrite();
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        actionUsrArticleList(rq);
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        actionUsrArticleDetail(rq);
      } else if (rq.getUrlPath().equals("/usr/article/modify")) {
        actionUsrArticleModify(rq);
      } else if (rq.getUrlPath().equals("/usr/article/delete")) {
        actionUsrArticleDelete(rq);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못 된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    Container.sc.close();
  }

  private static void actionUsrArticleDelete(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    articles.remove(article);

    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }

  private static void actionUsrArticleModify(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.print("새 제목 : ");
    article.subject = Container.sc.nextLine();

    System.out.print("새 내용 : ");
    article.content = Container.sc.nextLine();

    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }

  private static void actionUsrArticleWrite() {
    // lastArticleId 세팅
    lastArticleId = articles.get(articles.size() - 1).id;
    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = Container.sc.nextLine();

    System.out.print("내용 : ");
    String content = Container.sc.nextLine();

    int id = ++lastArticleId;

    Article article = new Article(id, subject, content);

    articles.add(article);

    System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
  }

  private static void actionUsrArticleDetail(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }

  private static void actionUsrArticleList(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    // 검색 기능 시작
    List<Article> filteredArticls = articles;

    if (params.containsKey("searchKeyword")) {
      String searchKeyword = params.get("searchKeyword");

      filteredArticls = new ArrayList<>();

      for (Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);

        if (matched) filteredArticls.add(article);
      }
    }
    // 검색 기능 끝

    // 정렬 로직 시작
    boolean orderByIdDesc = true;

    if (params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) {
      orderByIdDesc = false;
    }

    List<Article> sortedArticles = filteredArticls;

    if (orderByIdDesc) {
      sortedArticles = Util.reverseList(sortedArticles);
    }
    // 정렬 로직 끝

    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");

    sortedArticles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }

  private static Article finById(List<Article> articles, int id) {
    /*
    for (Article article : articles) {
      if (article.id == id) {
        return article;
      }
    }
    */

    return articles.stream()
        .filter(article -> article.id == id)
        .findFirst() // 첫 번째 요소 찾기
        .orElse(null);
  }
}

class Article {
  int id;
  String subject;
  String content;

  Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }

  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}

class Rq {
  String url;
  Map<String, String> params;
  String urlPath;

  Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }

  public Map<String, String> getParams() {
    return params;
  }

  public String getUrlPath() {
    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if (urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for (String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if (bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0];
  }

  // 이 함수는 원본리스트를 훼손하지 않고, 새 리스트를 만듭니다. 즉 정렬이 반대인 복사본리스트를 만들어서 반환합니다.
  public static <T> List<T> reverseList(List<T> list) {
    List<T> reverse = new ArrayList<>(list.size());

    for (int i = list.size() - 1; i >= 0; i--) {
      reverse.add(list.get(i));
    }
    return reverse;
  }
}
```
---
3. App 클래스 도입하여, 불필요했던 static 키워드를 대부분 제거

Main에서 호출되는 메서드들이 static일 수밖에 없어서 메모리가 낭비되고 있음
- static이 붙은 것은 프로그램이 로딩되자마자 생성됨
- 그렇기 때문에 static 프로그램을 실행하기 위해서는 static 메서드를 만들어줘야 함

코드 실행 순서
1. Main클래스에서 App객체 생성, run메서드 호출
2. App클래스에서 생성자메서드로 인스턴스 변수 생성되고
3. 요청에 따라 해당 코드 실행됨

#### App = 시작점 = 디스패처 서블릿

```java
public class App { // 위치 text_board.App.java
  // static이 제거됨
  List<Article> articles;
  int lastArticleId;

  App() { // 생성자메서드로 인스턴스 변수 생성
    articles = new ArrayList<>();
    lastArticleId = 0;
  }

  void makeTestData() {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }

  // 우리 로직의 시작점
  // Main에서 시작했을 때 붙여준 불필요한 static을 제거해줄 수 있음
  void run() {
    makeTestData();

    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      System.out.print("명령) ");
      String cmd = Container.sc.nextLine();

      Rq rq = new Rq(cmd);

      if (rq.getUrlPath().equals("/usr/article/write")) {
        actionUsrArticleWrite();
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        actionUsrArticleList(rq);
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        actionUsrArticleDetail(rq);
      } else if (rq.getUrlPath().equals("/usr/article/modify")) {
        actionUsrArticleModify(rq);
      } else if (rq.getUrlPath().equals("/usr/article/delete")) {
        actionUsrArticleDelete(rq);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못 된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    Container.sc.close();
  }

// static이 다 제거된 모습
  private void actionUsrArticleDelete(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    articles.remove(article);

    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }

  private void actionUsrArticleModify(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.print("새 제목 : ");
    article.subject = Container.sc.nextLine();

    System.out.print("새 내용 : ");
    article.content = Container.sc.nextLine();

    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }

  private void actionUsrArticleWrite() {
    lastArticleId = articles.get(articles.size() - 1).id;

    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = Container.sc.nextLine();

    System.out.print("내용 : ");
    String content = Container.sc.nextLine();

    int id = ++lastArticleId;

    Article article = new Article(id, subject, content);

    articles.add(article);

    System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
  }

  private void actionUsrArticleDetail(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }

    int id = 0;

    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }

  private void actionUsrArticleList(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    // 검색 기능 시작
    List<Article> filteredArticls = articles;

    if (params.containsKey("searchKeyword")) {
      String searchKeyword = params.get("searchKeyword");

      filteredArticls = new ArrayList<>();

      for (Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);

        if (matched) filteredArticls.add(article);
      }
    }
    // 검색 기능 끝

    // 정렬 로직 시작
    boolean orderByIdDesc = true;

    if (params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) {
      orderByIdDesc = false;
    }

    List<Article> sortedArticles = filteredArticls;

    if (orderByIdDesc) {
      sortedArticles = Util.reverseList(sortedArticles);
    }
    // 정렬 로직 끝

    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");

    sortedArticles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }

  private Article finById(List<Article> articles, int id) {
    return articles.stream()
        .filter(article -> article.id == id)
        .findFirst() // 첫 번째 요소 찾기
        .orElse(null);
  }
}
```
```java
public class Main {
  public static void main(String[] args) {
    App app = new App(); // App객체 만들어서
    app.run(); // run 메서드 호출
  }
}

class Article {
  int id;
  String subject;
  String content;

  Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }

  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}

class Rq {
  String url;
  Map<String, String> params;
  String urlPath;

  Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }

  public Map<String, String> getParams() {
    return params;
  }

  public String getUrlPath() {
    return urlPath;
  }
}

class Util {
  static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);

    if (urlBits.length == 1) {
      return params;
    }

    String queryStr = urlBits[1];

    for (String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);

      if (bits.length == 1) {
        continue;
      }

      params.put(bits[0], bits[1]);
    }

    return params;
  }

  static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0];
  }

  // 이 함수는 원본리스트를 훼손하지 않고, 새 리스트를 만듭니다. 즉 정렬이 반대인 복사본리스트를 만들어서 반환합니다.
  public static <T> List<T> reverseList(List<T> list) {
    List<T> reverse = new ArrayList<>(list.size());

    for (int i = list.size() - 1; i >= 0; i--) {
      reverse.add(list.get(i));
    }
    return reverse;
  }
}
```
---
4. 클래스별 파일 분리
일단 public으로 접근제한 변경
```java
public class Main {
  public static void main(String[] args) {
    App app = new App();
    app.run();
  }
}
```
```java
public class Article { // 위치 text_board.Article.java
  public int id; // private으로 막아줘야 함
  public String subject;
  public String content;
  public Article(int id, String subject, String content) {
    this.id = id;
    this.subject = subject;
    this.content = content;
  }
  @Override
  public String toString() {
    return "{id: %d, subject: \"%s\", content: \"%s\"}".formatted(id, subject, content);
  }
}
```
```java
public class Rq { // 위치 text_board.Rq.java
  public String url;
  public Map<String, String> params;
  public String urlPath;
  public Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }
  public Map<String, String> getParams() {
    return params;
  }
  public String getUrlPath() {
    return urlPath;
  }
}
```
```java
public class Util { // 위치 text_board.util.Util.java
  public static Map<String, String> getParamsFromUrl(String url) {
    Map<String, String> params = new HashMap<>();
    String[] urlBits = url.split("\\?", 2);
    if (urlBits.length == 1) {
      return params;
    }
    String queryStr = urlBits[1];
    for (String bit : queryStr.split("&")) {
      String[] bits = bit.split("=", 2);
      if (bits.length == 1) {
        continue;
      }
      params.put(bits[0], bits[1]);
    }
    return params;
  }
  public static String getPathFromUrl(String url) {
    return url.split("\\?", 2)[0];
  }
  // 이 함수는 원본리스트를 훼손하지 않고, 새 리스트를 만듭니다. 즉 정렬이 반대인 복사본리스트를 만들어서 반환합니다.
  public static <T> List<T> reverseList(List<T> list) {
    List<T> reverse = new ArrayList<>(list.size());
    for (int i = list.size() - 1; i >= 0; i--) {
      reverse.add(list.get(i));
    }
    return reverse;
  }
}
```
___
### 7. MVC 개념 설명, 컨트롤러 도입으로 리팩토링
52~55강
1. MVC와 컨트롤러 개념
2. ArticleController 클래스 도입
3. Rq.getIntParam 메소드 개요
4. rq.getIntParam, rq.getParam 을 도입하여 소스코드 다이어트
5. ArticleService, ArticleRepository 도입
6. 메이븐 리포지터리에 롬복 적용 해서 소스 코드 다이어트
---
1. MVC와 컨트롤러 개념

현재 App이 모든 일을 담당하고 있음

수정할 App이 할 일 
- 고객에게 요청을 받아 member와 관련된 일이면 member에게, article과 관련된 일이면 article에게

#### MVC 디자인 패턴
Model(모델): 서류 통과 심사 처리 후 입금 처리, 대출 처리 등
- 핵심 로직

View(화면)
- 보여지는 부분

Controller(컨트롤러): 은행 창구 직원(예금, 대출 등) - 서류 통과 심사
- 유효성 검사
---

#### 현재 프로젝트에 맞도록 MVC 설명
Model - 핵심로직

View - 고객이 보는 화면

Controller - 요청에 대한 유효성 검사

고객 > 은행 방문 > 청원 경찰(어떤 업무를 하러 왔는지 확인) > 은행 창구(예금, 대출)/ 필요 서류 확인 > 전산 처리 > 금고

- App(청원 경찰)
- Controller(은행 창구)
- Model(중요 업무 처리)
  - Service(은행 업무 처리)
  - Repository(은행의 금고, db 처리)
  - Dto(결과 통지서(member, article의 id, subject, content 등의 생성과 초기화가 하나의 양식임))

컨트롤러 -> 서비스 -> 리포지터리 순으로 도입

2. ArticleController 클래스 도입
컨트롤러가 다른 곳에서도 사용될 수 있기 때문에 컨테이너에 생성해줌
도입해야 할 mvc구조 - 현재 컨트롤러에서 이루어지는 처리 로직은 서비스에서, 테스트데이터 생성은 리포지터리에서 
```java
public class Container {
  public static Scanner sc;
  public static ArticleController articleController;

  static {
    sc = new Scanner(System.in);
    articleController = new ArticleController();
  }
}
```
```java
public class App {
  public ArticleController articleController;

  public App() {
    // 컨테이너 안에서 만들어진 컨트롤러 불러옴
    articleController = Container.articleController;
  }

  // 우리 로직의 시작점
  void run() {
    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      System.out.print("명령) ");
      String cmd = Container.sc.nextLine();

      Rq rq = new Rq(cmd);

      if (rq.getUrlPath().equals("/usr/article/write")) {
        articleController.doWrite(); // 메서드 이름 행위 = 동사로 수정
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        articleController.showList(rq);
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        articleController.showDetail(rq);
      } else if (rq.getUrlPath().equals("/usr/article/modify")) {
        articleController.doModify(rq);
      } else if (rq.getUrlPath().equals("/usr/article/delete")) {
        articleController.doDelete(rq);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못 된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    Container.sc.close();
  }
}
```
Article 클래스의 위치 article 패키지 안으로
```java
public class ArticleController { // 위치 /../article/ArticleController.java
  private List<Article> articles; // private로 잠궈줘야
  private int lastArticleId;
  public ArticleController() {
    articles = new ArrayList<>();
    lastArticleId = 0;
    makeTestData();
  }
  void makeTestData() {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }
  public void doWrite() {
    lastArticleId = articles.get(articles.size() - 1).id;
    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = Container.sc.nextLine();
    System.out.print("내용 : ");
    String content = Container.sc.nextLine();
    int id = ++lastArticleId;
    Article article = new Article(id, subject, content);
    articles.add(article);
    System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
  } 
  public void showList(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    // 검색 기능 시작
    List<Article> filteredArticls = articles;
    if (params.containsKey("searchKeyword")) {
      String searchKeyword = params.get("searchKeyword");
      filteredArticls = new ArrayList<>();
      for (Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);
        if (matched) filteredArticls.add(article);
      }
    }
    // 검색 기능 끝
    // 정렬 로직 시작
    boolean orderByIdDesc = true;
    if (params.containsKey("orderBy") && params.get("orderBy").equals("idAsc")) {
      orderByIdDesc = false;
    }
    List<Article> sortedArticles = filteredArticls;
    if (orderByIdDesc) {
      sortedArticles = Util.reverseList(sortedArticles);
    }
    // 정렬 로직 끝
    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");
    sortedArticles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }
  public void showDetail(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }
    Article article = finById(articles, id);
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }
  public void doModify(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }
    Article article = finById(articles, id);
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    System.out.print("새 제목 : ");
    article.subject = Container.sc.nextLine();
    System.out.print("새 내용 : ");
    article.content = Container.sc.nextLine();
    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }
  public void doDelete(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }
    Map<String, String> params = rq.getParams();
    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }
    Article article = finById(articles, id);
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    articles.remove(article);
    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }
  private Article finById(List<Article> articles, int id) {
    return articles.stream()
        .filter(article -> article.id == id)
        .findFirst() // 첫 번째 요소 찾기
        .orElse(null);
  }
}
```
---
3. Rq.getIntParam 메소드 개요

이 코드는 detail 코드에서 파라미터값을 가져오는 코드인데 너무 길다.
/usr/article/detail?id=1 중 1을 가져오는 코드.

`rq.getParams`를 통해 파라미터를 가져오도록 수정
- `rq.getParams`는 파라미터 여러 개를 가져옴
- `rq.getParams("id")`는 파라미터 중에 id만 달라는 것
- `int id = rq.getIntParams("id", 0)`는 정수로 형변환해서 가져와달라는 것
  - id가 존재하지 않는 경우 defaultValue로 0을 줘라
  - id(id == 0) {} 처리만 해주면 됨
```
// detail 코드 중 일부
Map<String, String> params = rq.getParams();
    if (!params.containsKey("id")) {
      System.out.println("id 값을 입력해주세요.");
      return;
    }
    int id = 0;
    try {
      id = Integer.parseInt(params.get("id"));
    } catch (NumberFormatException e) {
      System.out.println("id를 정수형태로 입력해주세요.");
      return;
    }
```
---
4. rq.getIntParam, rq.getParam 을 도입하여 소스코드 다이어트

```java
public class Rq {
  public String url;
  public Map<String, String> params;
  public String urlPath;
  
  public Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }
  
  public Map<String, String> getParams() {
    return params;
  }
  public String getUrlPath() {
    return urlPath;
  }
  
  // rq.getIntParam, getParam 도입
  // paramName 문자열이기 때문에 정수화해줘야
  // 값이 안 들어왔거나 정수가 아니거나의 처리를 해줘야 함
  public int getIntParam(String paramName, int defaultValue) {
    if(!params.containsKey(paramName)) { // 있는지 확인
      return defaultValue; // 없으면 defaultValue
    }
    try {
      return Integer.parseInt(params.get(paramName));
    } catch (NumberFormatException e) {
      return defaultValue;
    }
  }
  public String getParam(String paramName, String defaultValue) {
    if(!params.containsKey(paramName)) {
      return defaultValue;
    }
    return params.get(paramName);
  }
}
```
```java
public class ArticleController {
  private List<Article> articles;
  private int lastArticleId;

  public ArticleController() {
    articles = new ArrayList<>();
    lastArticleId = 0;

    makeTestData();
  }

  void makeTestData() {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> articles.add(new Article(i, "제목" + i, "내용" + i)));
  }

  public void doWrite() {
    lastArticleId = articles.get(articles.size() - 1).id;

    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = Container.sc.nextLine();

    System.out.print("내용 : ");
    String content = Container.sc.nextLine();

    int id = ++lastArticleId;

    Article article = new Article(id, subject, content);

    articles.add(article);

    System.out.printf("%d번 게시물이 등록되었습니다.\n", article.id);
  }

  public void showList(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    Map<String, String> params = rq.getParams();

    // 검색 기능 시작
    List<Article> filteredArticls = articles;
    // 4. rq.getParam 을 도입하여 소스코드 다이어트
    String searchKeyword = rq.getParam("searchKeyword", "");

    if (!searchKeyword.isEmpty()) { // 비어있지 않으면 데이터가 들어와있다는 것
      filteredArticls = new ArrayList<>();

      for (Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);

        if (matched) filteredArticls.add(article);
      }
    }
    // 검색 기능 끝

    // 정렬 로직 시작 - rq.getParam으로 수정됨
    String orderBy = rq.getParam("orderBy", "idDesc");
    boolean orderByIdDesc = orderBy.equals("idDesc");

    List<Article> sortedArticles = filteredArticls;

    if (orderByIdDesc) {
      sortedArticles = Util.reverseList(sortedArticles);
    }
    // 정렬 로직 끝

    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");

    sortedArticles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }

  public void showDetail(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    // 4. rq.getIntParam을 도입하여 소스코드 다이어트
    int id = rq.getIntParam("id", 0);

    if(id == 0) {
      System.out.println("올바른 값을 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }

  public void doModify(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    // 4. rq.getIntParam을 도입하여 소스코드 다이어트
    int id = rq.getIntParam("id", 0);

    if(id == 0) {
      System.out.println("올바른 값을 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.print("새 제목 : ");
    article.subject = Container.sc.nextLine();

    System.out.print("새 내용 : ");
    article.content = Container.sc.nextLine();

    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }

  public void doDelete(Rq rq) {
    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    // 4. rq.getIntParam을 도입하여 소스코드 다이어트
    int id = rq.getIntParam("id", 0);

    if(id == 0) {
      System.out.println("올바른 값을 입력해주세요.");
      return;
    }

    Article article = finById(articles, id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    articles.remove(article);

    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }

  private Article finById(List<Article> articles, int id) {
    return articles.stream()
        .filter(article -> article.id == id)
        .findFirst() // 첫 번째 요소 찾기
        .orElse(null);
  }
}
```
---
5. ArticleService, ArticleRepository 도입

요청 순서
Controller -> Service -> Repository

프로그램이 실행되자마자 만들어져야하는 순서
Repository -> Service -> Controller

코드를 컨트롤러, 서비스, 리포지터리로 분리시켜 코드를 알아보기 쉬워짐. 유지보수하기 쉬워짐.
```java
public class Container {
  // 생성순서 중요 Repository -> Service -> Controller
  public static Scanner sc;
  public static ArticleRepository articleRepository;
  public static ArticleService articleService;
  public static ArticleController articleController;

  static {
    sc = new Scanner(System.in);
    articleRepository = new ArticleRepository();
    articleService = new ArticleService();
    articleController = new ArticleController();
  }
}
```
```java
public class ArticleController {

  private ArticleService articleService; // 컨테이너 -> 서비스로 이어지는 로직

  public ArticleController() {
    articleService = Container.articleService;
  }

  public void doWrite() {
    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = Container.sc.nextLine();

    // 컨트롤러에서 해야 하는 유효성 검사
    if(subject.trim().isEmpty()) {
      System.out.println("제목을 입력해주세요.");
      return;
    }

    System.out.print("내용 : ");
    String content = Container.sc.nextLine();

    if(content.trim().isEmpty()) {
      System.out.println("내용을 입력해주세요.");
      return;
    }

    // 1-1. articleService에 subject와 content를 넘겨주는 write 메서드 생성
    int id = articleService.write(subject, content);

    System.out.printf("%d번 게시물이 등록되었습니다.\n", id);
  }

  // 2-1. 기존 articles를 리포지터리로 옮겨주었기 때문에 수정하는 것이 까다로움
  public void showList(Rq rq) {
    String searchKeyword = rq.getParam("searchKeyword", "");
    String orderBy = rq.getParam("orderBy", "idDesc");

    // getArticles로 데이터를 가져올 수 있도록 메서드 생성
    List<Article> articles = articleService.getArticles(searchKeyword, orderBy);

    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");

    articles.forEach(
        article -> System.out.printf("%d | %s\n", article.id, article.subject)
    );
  }

  public void showDetail(Rq rq) {
    int id = rq.getIntParam("id", 0);

    if(id == 0) {
      System.out.println("올바른 값을 입력해주세요.");
      return;
    }

    Article article = articleService.findById(id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.id);
    System.out.printf("제목 : %s\n", article.subject);
    System.out.printf("내용 : %s\n", article.content);
  }

  public void doModify(Rq rq) {
    int id = rq.getIntParam("id", 0);

    if(id == 0) {
      System.out.println("올바른 값을 입력해주세요.");
      return;
    }

    Article article = articleService.findById(id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    System.out.print("새 제목 : ");
    // 컨트롤러가 데이터를 처리하면 안 되기 때문에 subject, content 타입이 String
    String subject = Container.sc.nextLine();

    if(subject.trim().isEmpty()) {
      System.out.println("제목을 입력해주세요.");
      return;
    }

    System.out.print("새 내용 : ");
    String content = Container.sc.nextLine();

    if(content.trim().isEmpty()) {
      System.out.println("내용을 입력해주세요.");
      return;
    }

    // 입력 받은 데이터를 처리하도록 서비스로 보냄
    articleService.modify(id, subject, content);

    System.out.printf("%d번 게시물이 수정되었습니다.\n", id);
  }

  public void doDelete(Rq rq) {
    int id = rq.getIntParam("id", 0);

    if(id == 0) {
      System.out.println("올바른 값을 입력해주세요.");
      return;
    }

    Article article = articleService.findById(id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    articleService.delete(id);

    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
  }
}
```
```java
public class ArticleRepository { // article패키지 안
  private List<Article> articles; // 리포지터리에 구현하게 됨
  private int lastId; // 기존 컨트롤러 -> 현재 리포지터리로 전환 완료
  public ArticleRepository() {
    articles = new ArrayList<>();
    lastId = 0;
  }
  // 1-3. 리포지터리에서 처리하는 과정
  public int write(String subject, String content) {
    int id = ++lastId; // id값 증가시켜줌
    Article article = new Article(id, subject, content);
    articles.add(article);
    return id; // id만 넘겨주면 됨
  }
  // 2-3. 정렬 로직
  public List<Article> getSortedArticles(String orderBy) {
    List<Article> sortedArticles = articles; // 정렬되지 않은 상태
    if(orderBy.equals("idAsc")) {
      return articles;
    }
    if (orderBy.equals("idDesc")) {
      sortedArticles = Util.reverseList(articles); // 뒤짚어서
    }
    return sortedArticles; // 뒤짚어진 articles를 리턴
  }
  // 2-3. searchKeyword
  public List<Article> getArticles(String searchKeyword, String orderBy) {
    List<Article> filteredArticls = getSortedArticles(orderBy);
    if (!searchKeyword.trim().isEmpty()) { // trim: 문자열의 양옆 공백을 제거하는데 isEmpty 비어있나      filteredArticls = new ArrayList<>();
      for (Article article : articles) {
        boolean matched = article.subject.contains(searchKeyword) || article.content.contains(searchKeyword);
        if (matched) filteredArticls.add(article);
      }
    }
    return filteredArticls;
  }
  public void modify(int id, String subject, String content) {
    Article article = findById(id);
    if(article != null) { // 찾은 상태
      article.subject = subject; //article.subject에 입력받은 subject 넣어주기
      article.content = content;
    }
  }
  public void delete(int id) {
    Article article = findById(id);
    if(article != null) {
      articles.remove(article);
    }
  }
  public Article findById(int id) {
    return articles.stream()
        .filter(article -> article.id == id)
        .findFirst()
        .orElse(null);
  }
}
```
```java
public class ArticleService { // article패키지 안
  private ArticleRepository articleRepository; // 리포지터가 필요
  public ArticleService() {
    articleRepository = Container.articleRepository; // 컨테이너 속 리모콘 연결
    makeTestData();
  }
  void makeTestData() { // 테이스 게시물의 경우 서비스 수준에서 구현하면 됨
    IntStream.rangeClosed(1, 100)
        .forEach(i -> write("제목" + i, "내용" + i));
  }
  // 1-2. 데이터 처리는 리포지터리에서 실행하기 때문에 리포지터리로 넘겨줌
  public int write(String subject, String content) {
    return articleRepository.write(subject, content);
  }
  // 2-2. 컨트롤러에서 searchKeyword와 orderBy를 넘겨받아 리포지터리로 넘겨준다
  public List<Article> getArticles(String searchKeyword, String orderBy) {
    return articleRepository.getArticles(searchKeyword, orderBy);
  }
  public Article findById(int id) {
    return articleRepository.findById(id);
  }
  public void modify(int id, String subject, String content) {
    articleRepository.modify(id, subject, content);
  }
  public void delete(int id) {
    articleRepository.delete(id);
  }
}
```
---
6. 메이븐 리포지터리에 롬복 적용 해서 소스 코드 다이어트

[메이븐 리포지터리](https://mvnrepository.com/)

pom.xml 수정사항(<properties> 위에 도입)

pom.xml은 주문서라고 생각하면 된다.
```
<dependencies>
    <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <version>1.18.34</version>
      <scope>provided</scope>
    </dependency>
</dependencies>
```
롬복 사용하는 이유: Article 클래스의 변수를 추가하며 계속해서 게터와 세터를 생성해주는 것은 좋지 않기 때문에 롬복으로 간소화하여 작성한다!
`롬복`(alt+7 입력 시 내용 확인 가능)
`@NoArgsConstructor` : 파라미터 없는 기본 생성자를 만들어줌

`@AllArgsConstructor` : 모든 필드 값을 파라미터로 받는 생성자를 만들어줌

`@Data` : Getter, Setter, toString 등을 자동으로 생성
```java
@NoArgsConstructor
@AllArgsConstructor
@Data
public class Article {
  private int id; // private 접근제한자로 막아야 하지만 오류 발생
  private String subject; // ArticleController 등 다른 클래스가 접근하지 못 하게 됨
  private String content; // 게터, 세터를 통해 다른 클래스에서 접근 가능
}
```
```java
public class Rq {
  public String url;

  @Getter
  public Map<String, String> params;

  @Getter
  public String urlPath;

  public Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
  }
  // 생략
}
```
```java
public class ArticleController {

  private ArticleService articleService;

  public ArticleController() {
    articleService = Container.articleService;
  }
  // 생략
  public void showList(Rq rq) {
    String searchKeyword = rq.getParam("searchKeyword", "");
    String orderBy = rq.getParam("orderBy", "idDesc");

    List<Article> articles = articleService.getArticles(searchKeyword, orderBy);

    if (articles.isEmpty()) {
      System.out.println("현재 게시물이 존재하지 않습니다.");
      return;
    }

    System.out.println("== 게시물 리스트 ==");
    System.out.println("번호 | 제목");

    // 수정사항
    articles.forEach(
            article -> System.out.printf("%d | %s\n", article.getId(), article.getSubject())
    );
  }
  public void showDetail(Rq rq) {
    int id = rq.getIntParam("id", 0);

    if(id == 0) {
      System.out.println("올바른 값을 입력해주세요.");
      return;
    }

    Article article = articleService.findById(id);

    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    System.out.println("== 게시물 상세보기 ==");
    // 수정사항
    System.out.printf("번호 : %d\n", article.getId());
    System.out.printf("제목 : %s\n", article.getSubject());
    System.out.printf("내용 : %s\n", article.getContent());
  }
  // 생략
}
```
```java
public class ArticleRepository {
  private List<Article> articles;
  private int lastId;

  public ArticleRepository() {
    articles = new ArrayList<>();
    lastId = 0;
  }

  // 생략
  public List<Article> getArticles(String searchKeyword, String orderBy) {
    List<Article> filteredArticls = getSortedArticles(orderBy);

    if (!searchKeyword.trim().isEmpty()) {
      filteredArticls = new ArrayList<>();

      // 수정사항
      for (Article article : articles) {
        boolean matched = article.getSubject().contains(searchKeyword) || article.getContent().contains(searchKeyword);

        if (matched) filteredArticls.add(article);
      }
    }

    return filteredArticls;
  }

  public void modify(int id, String subject, String content) {
    Article article = findById(id);

    if (article != null) {
      // 수정사항
      article.setSubject(subject);
      article.setContent(content);
    }
  }

  // 생략
  public Article findById(int id) {
    return articles.stream()
            // 수정사항
        .filter(article -> article.getId() == id)
        .findFirst()
        .orElse(null);
  }
}
```
---
### 8. 회원가입, 로그인, 세션으로 중복 로그인 방지, 로그아웃
58~65강

1. 회원가입 기능 구현
2. 로그인 기능 구현
3. 회원 테스트 데이터 추가
4. 회원 가입시 중복 loginId로 회원 가입 금지
5. 세션을 도입하려는 이유 설명
6. 세션을 이용한 중복 로그인 금지
7. 세션을 이용한 prompt 이름 변경
8. 로그아웃 구현
---
1. 회원가입 기능 구현
회원가입 기능 구현 만드는 순서
Container에 Member의 리포지터리, 서비스, 컨트롤러 생성 -> Member 클래스 생성 -> App 클래스에 MemberController 가져오고 url 생성(doJoin) ->
MemberController에서 서비스 호출해주고 doJoin 메서드 구현, 유효성 처리 및 입력된 값을 서비스에 보내고 서비스, 리포지터리 구현

5. 세션을 도입하려는 이유 설명
중복 로그인을 막을 수 있는 방법 - `세션`

서버(스프링부트), 클라이언트(웹 브라우저)

자바의 요청사항
/usr/article/list
/usr/article/write

`세션` -> key, value 형태로 데이터를 관리함
- 웹 브라우저(크롬)에서 로그인 요청
- 서버에서 세션(키, 값) 발급(세션은 고유한 값)
- 웹 브라우저(크롬) 내의 세션이라는 저장소에 저장된 것 확인 가능
- f12 - Application - Session storage

요청 사항: /usr/member/login

로그인 검증
- 아이디, 비밀번호
- 해당 아이디, 비밀번호가 일치하는지 확인
- 불일치하면 로그인 되지 않도록

로그인 통과
- 세션 ID 발급!
- key: "loginedMemberId" | value: member
- 세션 키값이 loginedMemberId을 가지고 있으면 로그인 된 상태이기 때문에 로그아웃 기능구현과 중복로그인 못 하도록 막을 수 있음

웹 브라우저 종료하고 바로 세션이 만료되지 않는 까닭
- 로그인 유지하기가 가능한 이유는
- 세션 아이디가 그대로 유지될 수 있도록 설정되어 있기 때문

```java
public class Container {
  public static Scanner sc;
  // 6. 세션을 이용한 중복 로그인 금지
  public static Session session;

  public static MemberRepository memberRepository;
  public static ArticleRepository articleRepository;

  public static MemberService memberService;
  public static ArticleService articleService;

  public static MemberController memberController;
  public static ArticleController articleController;

  static {
    sc = new Scanner(System.in);
    session = new Session();

    memberRepository = new MemberRepository();
    articleRepository = new ArticleRepository();

    memberService = new MemberService();
    articleService = new ArticleService();

    memberController = new MemberController();
    articleController = new ArticleController();
  }
}
```
```java
@NoArgsConstructor
@AllArgsConstructor
@Data
public class Member {
  private int id;
  private String loginId;
  private String loginPw;
  private String name;
}
```
7. 세션을 이용한 prompt 이름 변경
```java
public class App {
  public MemberController memberController;
  public ArticleController articleController;

  public App() {
    memberController = Container.memberController;
    articleController = Container.articleController;
  }
  // 우리 로직의 시작점
  void run() {
    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      // 7. 세션을 이용한 prompt 이름 변경
      Session session = Container.session;
      Member member = (Member) session.getAttribute("loginedMember"); // 타입이 Member 이기 때문에 형변환
      String promptName = "명령";
      if(member != null) { // 데이터를 가져올 수 있다 = 로그인된 멤버가 있다
        promptName = member.getLoginId();
      }
      System.out.printf("%s) ", promptName); 
      String cmd = Container.sc.nextLine();

      Rq rq = new Rq(cmd);

      if (rq.getUrlPath().equals("/usr/article/write")) {
        articleController.doWrite();
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        articleController.showList(rq);
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        articleController.showDetail(rq);
      } else if (rq.getUrlPath().equals("/usr/article/modify")) {
        articleController.doModify(rq);
      } else if (rq.getUrlPath().equals("/usr/article/delete")) {
        articleController.doDelete(rq);
      } // 1. 회원가입 기능 구현
      else if (rq.getUrlPath().equals("/usr/member/join")) {
        memberController.doJoin(rq);
      } // 2. 로그인 기능 구현, rq를 통해 로그인이 되었는지 확인하려고 rq도 넘겨줌
      else if (rq.getUrlPath().equals("/usr/member/login")) {
        memberController.doLogin(rq);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못 된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    Container.sc.close();
  }
}
```
```java
public class MemberController {
  private MemberService memberService;
  public MemberController() {
    memberService = Container.memberService;
  }
  // 1. 회원가입 기능 구현
  public void doJoin(Rq rq) {
    String loginId;
    String loginPW;
    String loginPwConfirm;
    String name;
    Member member; // 4. 회원 가입시 중복 loginId로 회원 가입 금지
    
    System.out.println("== 회원가입 ==");
    // 로그인 아이디 입력
    while (true) {
      System.out.print("로그인 아이디 : ");
      loginId = Container.sc.nextLine();
      // 4. 회원 가입시 중복 loginId로 회원 가입 금지
      member = memberService.findByLoginId(loginId);
      if(member != null) {
        System.out.printf("\"%s\"(은)는 이미 가입 된 로그인 아이디입니다.\n", loginId);
        continue;
      }

      if(loginId.trim().isEmpty()) { // 입력될 때까지 반복하도록
        System.out.println("로그인 아이디를 입력해주세요.");
        continue;
      }
      break;
    }
    // 로그인 비밀번호 입력
    while (true) {
      System.out.print("로그인 비밀번호 : ");
      loginPW = Container.sc.nextLine();
      if(loginPW.trim().isEmpty()) {
        System.out.println("로그인 비밀번호를 입력해주세요.");
        continue;
      }
      while (true) {
        System.out.print("로그인 비밀번호 확인 : ");
        loginPwConfirm = Container.sc.nextLine();
        if(loginPwConfirm.trim().isEmpty()) {
          System.out.println("로그인 비밀번호 확인을 입력해주세요.");
          continue;
        }
        if(!loginPwConfirm.equals(loginPW)) {
          System.out.println("비밀번호가 일치하지 않습니다.");
          continue;
        }
        break;
      }
      break;
    }
    // 이름 입력
    while (true) {
      System.out.print("이름 : ");
      name = Container.sc.nextLine();
      if(name.trim().isEmpty()) {
        System.out.println("이름을 입력해주세요.");
        continue;
      }
      break;
    }
    // 서비스로 입력받은 내용 넘겨줌
    memberService.join(loginId, loginPW, name);
    System.out.printf("\"%s\"님 회원 가입되었습니다.\n", name);
  }
  
  // 2. 로그인 기능 구현(회원가입과 유사)
  public void doLogin(Rq rq) {
    String loginId;
    String loginPW;
    Member member;
    // 6. 세션을 이용한 중복 로그인 금지
    if(rq.isLogined()) { // 처음에는 false라 실행되고 이후 true라 로그인 안됨
      System.out.println("이미 로그인 되어 있습니다.");
      return;
    }
    System.out.println("== 로그인 ==");

    // 로그인 아이디 입력
    while (true) {
      System.out.print("로그인 아이디 : ");
      loginId = Container.sc.nextLine();
      member = memberService.findByLoginId(loginId); // 로그인 아이디가 이미 존재하는지 확인해야 함
      if(member == null) { // 유효성 검사 처리
        System.out.printf("\"%s\"(은)는 존재하지 않는 아이디입니다.\n", loginId);
        continue;
      }
      if (loginId.trim().isEmpty()) {
        System.out.println("로그인 아이디를 입력해주세요.");
        continue;
      }
      break;
    }
    // 비밀번호 3번까지 틀려도 통과할 수 있도록 기능 추가
    int tryMaxCount = 3; // 최대 시도 횟수
    int tryCount = 0;
    boolean loginIsSuccess = false;
    // 로그인 비밀번호 입력
    while (true) {
      if(tryCount == tryMaxCount) { // 비밀번호 입력 횟수 초과시
        System.out.println("비밀번호를 확인 후 다시 입력해 주세요.");
        break;
      }
      System.out.print("로그인 비밀번호 : ");
      loginPW = Container.sc.nextLine();
      if (loginPW.trim().isEmpty()) {
        System.out.println("로그인 비밀번호를 입력해주세요.");
        continue;
      }
      if(!member.getLoginPw().equals(loginPW)) {
        tryCount++;
        System.out.println("비밀번호가 일치하지 않습니다.");
        System.out.printf("일치하지 않은 횟수( %d / %d )\n", tryCount, tryMaxCount);
        continue;
      }
      loginIsSuccess = true; // 로그인 성공 시 true로 설정
      break;
    }
    if(loginIsSuccess) {
      System.out.printf("\"%s\"님 로그인 되었습니다.\n", loginId);
      // 6. 세션을 이용한 중복 로그인 금지(키(세션id) loginedMember, 값 member을 넘겨줌)
      rq.setSessionAttr("loginedMember", member);
    }
    else {
      System.out.println("로그인을 실패하였습니다.");
    }
  }
}
```
```java
public class MemberService {
  private MemberRepository memberRepository;
  public MemberService() {
    memberRepository = Container.memberRepository;
  }
  // 1. 회원가입 기능 구현
  public void join(String loginId, String loginPW, String name) {
    memberRepository.join(loginId, loginPW, name);
  }
  // 2. 로그인 기능 구현
  public Member findByLoginId(String loginId) { // 입력한 id와 객체 id가 일치하는 것 찾는 메서드
    return memberRepository.findByLoginId(loginId);
  }
}
```
```java
public class MemberRepository {
  private List<Member> members; // 회원가입 데이터가 members에 저장됨
  private int lastId;
  public MemberRepository() {
    members = new ArrayList<>();
    lastId = 0;

    // 3. 회원 테스트 데이터 추가
    makeTestData();
  }
  void makeTestData() {
    members.add(new Member(1, "user1", "1234", "김철수"));
    members.add(new Member(2, "love", "2345", "김덕희"));
    members.add(new Member(3, "hello", "12555", "최영희"));
  }
  // 1. 회원가입 기능 구현
  // write 메서드와 유사하기 때문에 그대로 가져옴
  public void join(String loginId, String loginPW, String name) {
    int id = ++lastId;
    Member member = new Member(id, loginId, loginPW, name);
    members.add(member);
  }
  // 2. 로그인 기능 구현
  // 입력한 id와 객체 id가 일치하는 것 찾는 메서드
  public Member findByLoginId(String loginId) {
    return members.stream()
            .filter(member -> member.getLoginId().equals(loginId))
            .findFirst()
            .orElse(null);
  }
}
```
3. 테스트 데이터 Article 관련 클래스들 수정
수정한 이유: 리포지터리가 데이터베이스는 아니지만 데이터베이스가 없는 현재, db역할도 담당할 수 있도록 리포지터리에서 테스트 데이터 생성
```java
public class ArticleRepository {
  private List<Article> articles;
  private int lastId;

  public ArticleRepository() {
    articles = new ArrayList<>();
    lastId = 0;
    // ArticleService에서 생성하던 makeTestData를 리포지터리로 이동
    makeTestData();
  }

  void makeTestData() {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> write("제목" + i, "내용" + i));
  }
  // 생략
}
```
```java
public class ArticleService {
  private ArticleRepository articleRepository;

  public ArticleService() {
    articleRepository = Container.articleRepository;
  }
  // 생략
}
```
6. 세션을 이용한 중복 로그인 금지
세션
- 세션 데이터 저장
- 세션 데이터 조회(가져오기)
- 세션 데이터 유무 확인
- 세션 데이터 삭제
```java
public class Session { // 위치 base.session.Session.java
  private Map<String, Object> sessionData; // 키값으로 이루어져 있어서 map 사용
  public Session() {
    sessionData = new LinkedHashMap<>(); // 순서를 보장하는 맵
  }
  // 세션 데이터 조회
  public Object getAttribute(String attrName) {
    return sessionData.get(attrName);
  }
  // 세션 데이터 저장
  public void setAttribute(String attrName, Object value) {
    sessionData.put(attrName, value);
  } 
  // 세션 데이터 유무 확인 
  public boolean hasAttribute(String attrName) {
    return sessionData.containsKey(attrName); // containsKey 외워야,,
  }
  // 세션 데이터 삭제
  public void removeAttribute(String attrName) {
    sessionData.remove(attrName);
  }
}
```
```java
public class Rq { // Article, Member, Reply 등에서 필요한 것들 모아두는 클래스
  // 퍼사드 패턴: 범용적으로 사용하는 것들을 모아둠
  public String url;
  @Getter
  public Map<String, String> params;
  @Getter
  public String urlPath;
  public Session session; // 세션을 Rq에서 사용할 수 있도록
  public String loginedMember = "loginedMember"; // loginedMember를 전역변수로 두고 공유할 수 있도록
  public Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
    session = Container.session;
  }
  // 생략
  
  // isLogined는 세션에 넘겨준 loginedMember가 있는지 확인
  // 세션에서 해당 세션 ID가 있으면 true를 반환, 없으면 false를 반환
  public boolean isLogined() {
    return hasSessionAttr(loginedMember);
  }
  public boolean isLogout() {
    return !isLogined();
  }
  public Object getSessionAttr(String attrName) {
    return session.getAttribute(attrName);
  }
  public void setSessionAttr(String attrName, Object value) {
    session.setAttribute(attrName, value);
  }
  public boolean hasSessionAttr(String attrName) {
    return session.hasAttribute(attrName);
  }
  public void removeSessionAttr(String attrName) {
    session.removeAttribute(attrName);
  }
}
```

8. 로그아웃 구현
```java
public class App {
  public MemberController memberController;
  public ArticleController articleController;

  public App() {
    memberController = Container.memberController;
    articleController = Container.articleController;
  }
  // 우리 로직의 시작점
  void run() {
    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      // 7. 세션을 이용한 prompt 이름 변경
      Session session = Container.session;
      Member member = (Member) session.getAttribute("loginedMember"); // 타입이 Member 이기 때문에 형변환
      String promptName = "명령";
      if(member != null) { // 데이터를 가져올 수 있다 = 로그인된 멤버가 있다
        promptName = member.getLoginId();
      }
      System.out.printf("%s) ", promptName); 
      String cmd = Container.sc.nextLine();

      Rq rq = new Rq(cmd);

      if (rq.getUrlPath().equals("/usr/article/write")) {
        articleController.doWrite();
      } else if (rq.getUrlPath().equals("/usr/article/list")) {
        articleController.showList(rq);
      } else if (rq.getUrlPath().equals("/usr/article/detail")) {
        articleController.showDetail(rq);
      } else if (rq.getUrlPath().equals("/usr/article/modify")) {
        articleController.doModify(rq);
      } else if (rq.getUrlPath().equals("/usr/article/delete")) {
        articleController.doDelete(rq);
      } // 1. 회원가입 기능 구현
      else if (rq.getUrlPath().equals("/usr/member/join")) {
        memberController.doJoin(rq);
      } // 2. 로그인 기능 구현, rq를 통해 로그인이 되었는지 확인하려고 rq도 넘겨줌
      else if (rq.getUrlPath().equals("/usr/member/login")) {
        memberController.doLogin(rq);
        // 8. 로그아웃 기능 구현
      } else if (rq.getUrlPath().equals("/usr/member/logout")) {
        memberController.doLogout(rq);
      } else if (rq.getUrlPath().equals("exit")) {
        System.out.println("프로그램을 종료합니다.");
        break;
      } else {
        System.out.println("잘못 된 명령어입니다.");
      }
    }

    System.out.println("== 자바 텍스트 게시판 종료 ==");
    Container.sc.close();
  }
}
```
```java
public class MemberController {
  private MemberService memberService;
  public MemberController() {
    memberService = Container.memberService;
  }
  // 생략
  // 로그아웃 기능 구현
  public void doLogout(Rq rq) {
    if(rq.isLogout()) {
      System.out.println("로그인 후 이용해주세요.");
      return;
    }
    // Rq의 removeSessionAttr을 하면 loginedMember를 넘겨주고 SessionData 맵에서 해당 이름 삭제(key, value 삭제됨) 
    rq.removeSessionAttr("loginedMember"); // loginedMember 제거
    System.out.println("로그아웃 되었습니다.");
  }
}
```

### 9. 인터셉터 Interceptor
NeedLoginInterceptor, NeedLogoutInterceptor 도입

/usr/article/write, 
/usr/article/modify, 
/usr/article/delete

위 기능은 로그인 하지 않으면 사용할 수 없어야 한다

/usr/member/join, 
/usr/member/login

위 기능은 현재 임시 세션으로 로그인한 회원 여부를 판단하고 이미 로그인 되어 있으면 재로그인 불가능하게 구현했음.
join 또한 로그인된 상태인지 판단하고 회원가입 진행해야 함.

그렇기 때문에 `인터셉터`를 도입하여 로그인 여부를 판단할 수 있도록 도입함!
`인터셉터 = 가로채는 역할`

클라이언트가 요청함 -> App이 디스패처 서블릿의 역할 -> App이 article 요청인지, member 요청인지 구분하여 각각의 컨트롤러에게 보냄
- App에서 로그인되지 않은 회원이 write, modify, delete 등을 하려고 하면
- 컨트롤러로 넘어가지 않도록 인터셉터가 가로챔
- 로그인 되지 않은 회원이 게시물 작성하려고 하면 로그인 후 이용가능하도록 조정
- 자바 텍스트 게시판이기 때문에 인터셉터를 도입하는 것이지 이후에는 인터셉터를 직접 구현하지 않는다

1. 인터페이스 인터셉터를 만들어준다
```java
package com.sbs.java.text_board.base.interceptor;
public interface Interceptor {
  boolean run(Rq rq);
}
```

2. 싱글톤 패턴으로 작업하고 있으므로 컨테이너에 인터셉터 넣어줌
```java
public class Container {
  public static Scanner sc;
  public static Session session;

  public static NeedLoginInterceptor needLoginInterceptor;
  public static NeedLogoutInterceptor needLogoutInterceptor;

  // 생략
  static {
    sc = new Scanner(System.in);
    session = new Session();

    needLoginInterceptor = new NeedLoginInterceptor();
    needLogoutInterceptor = new NeedLogoutInterceptor();

    // 생략
  }
}
```

회원가입, 로그인은 로그인 상태에서만 로그아웃이 되어야됨
- 그렇기 때문에 인터셉터를 로그인과 로그아웃 버전으로 만들어줌
```java
package com.sbs.java.text_board.base.interceptor;
// 추상 100% 클래스는 인터페이스로 구현
// Interceptor를 상속받으면 NeedLoginInterceptor에 메서드 오버라이딩 필수
public class NeedLoginInterceptor implements Interceptor {
  @Override
  public boolean run(Rq rq) {
    if(rq.isLogined()) return true; // 로그인 되어있는 경우
    return switch (rq.getUrlPath()) { // 로그인이 필요한 경우
      case "/usr/article/write",
              "/usr/article/modify",
              "/usr/article/delete",
              "/usr/member/logout" -> {
        System.out.println("로그인 후 이용해주세요.");
        yield false; // yield = return
      }
      default -> true;
    };
  }
}
```
```java
package com.sbs.java.text_board.base.interceptor;
public class NeedLogoutInterceptor implements Interceptor {
  @Override
  public boolean run(Rq rq) {
    if(rq.isLogout()) return true; // 로그아웃 되어있다
    return switch (rq.getUrlPath()) { // 로그인 되어야 사용 가능
      case "/usr/member/login",
              "/usr/member/join",
              "/usr/member/findLoginId", // findLoginId 아직 구현되진 않았지만 이런 경우도 가능하다
              "/usr/member/findLoginPw" -> {
        System.out.println("이미 로그인 상태입니다.");
        yield false;
      }
      default -> true;
    };
  }
}
```

App클래스의 일부
```java
public class App {
  public MemberController memberController;
  public ArticleController articleController;

  public App() {
    memberController = Container.memberController;
    articleController = Container.articleController;
  }

  // 우리 로직의 시작점
  void run() {
    System.out.println("== 자바 텍스트 게시판 시작 ==");

    while (true) {
      Session session = Container.session;

      Member member = (Member) session.getAttribute("loginedMember");

      String promptName = "명령";

      if (member != null) {
        promptName = member.getLoginId();
      }

      System.out.printf("%s) ", promptName);
      String cmd = Container.sc.nextLine();

      Rq rq = new Rq(cmd);

      // 인터셉터 도입
      if (!runInterceptor(rq)) { // 로그인이 되어야 실행되는 기능은 이 코드로 인해 false라면 인터셉터로 넘어감
        continue;
      }
      // 생략
    }
    System.out.println("== 자바 텍스트 게시판 종료 ==");
    Container.sc.close();
  }

  private boolean runInterceptor(Rq rq) {
    List<Interceptor> interceptors = new ArrayList<>();

    // 컨테이너의 인터셉터 주소값 넣어줌
    interceptors.add(Container.needLoginInterceptor);
    interceptors.add(Container.needLogoutInterceptor);

    for(Interceptor interceptor : interceptors) {
      if(!interceptor.run(rq)) { // rq를 넘겨줬을 때 true이면 로그인이나 로그아웃이 되어있는 상태
        // false면 "로그인 후 이용해주세요." 로 넘어감
        return false;
      }
    }

    return true;
  }
}
```

MemberController의 일부
App의 if (!runInterceptor(rq)) {continue;}를 통해 로그인 여부을 하였기 때문에 아래 코드 삭제해줌
```java
public void doLogin(Rq rq) {
  String loginId;
  String loginPW;
  Member member;

  // 여기서부터
  if (rq.isLogined()) {
    System.out.println("이미 로그인 되어 있습니다.");
    return;
  }
  // 여기까지 삭제
  
  System.out.println("== 로그인 ==");
}

  public void doLogout(Rq rq) {
    // 여기서부터
    if (rq.isLogout()) {
      System.out.println("로그인 후 이용해주세요.");
      return;
    }
    // 여기까지 삭제

    rq.removeSessionAttr("loginedMember");

    System.out.println("로그아웃 되었습니다.");
  }
```

### 10. 게시물 작성 관련 추가 기능 구현
1. 게시물 작성시 로그인 한 회원의 이름이 등록 되도록
2. 게시물 작성자가 아닌 경우 게시물 수정, 삭제가 안되도록 권한처리

---
1. 게시물 작성시 로그인 한 회원의 이름이 등록 되도록\
게시물 작성은 articleController - doWrite

게시물 작성시 작성자명이 등록되도록 -> 게시물 수정/삭제 시 작성자의 권한 체크(1번 회원 1번 글 작성 1번 글 수정삭제 권한)

Article클래스 수정
```
// 생략
  private String content;
  private String writerName; // 작성자명 추가
  private int memberId;
}
```

App클래스
```
if (rq.getUrlPath().equals("/usr/article/write")) {
    articleController.doWrite(rq);
}
```

```
public class ArticleController {
  private ArticleService articleService;
  private Session session; // 세션 도입

  public ArticleController() {
    articleService = Container.articleService;
    session = Container.session;
  }

  public void doWrite(Rq rq) { // rq 추가
    System.out.println("== 게시물 작성 ==");
    System.out.print("제목 : ");
    String subject = Container.sc.nextLine();
    // 생략
  }

  // 삭제 int id = articleService.write(subject, content);
  Member member = (Member) session.getAttribute("loginedMember");
  int id = articleService.write(subject, content, member.getName()); // member 이름 넘겨줌

  // 생략
}
  System.out.println("== 게시물 리스트 ==");
  System.out.println("번호 | 제목 | 작성자"); // 추가

  articles.forEach( // 추가
    article -> System.out.printf("%d | %s | %s\n", article.getId(), article.getSubject(), article.getWriterName())
    );
  }

    // 생략
    
    System.out.println("== 게시물 상세보기 ==");
    System.out.printf("번호 : %d\n", article.getId());
    System.out.printf("작성자 : %s\n", article.getWriterName()); // 추가
    System.out.printf("제목 : %s\n", article.getSubject());
    System.out.printf("내용 : %s\n", article.getContent());
  }
  
  // 생략
```
ArticleService 일부 수정
```java
public int write(String subject, String content, String name) {
    return articleRepository.write(subject, content, name);
  }
```
ArticleRepository 일부
```java
void makeTestData() {
    IntStream.rangeClosed(1, 100)
      .forEach(i -> write("제목" + i, "내용" + i, "익명")); // 테스트데이터 작성자명 익명 -> 수정불가
}
public int write(String subject, String content, String name) {
  int id = ++lastId;
  Article article = new Article(id, subject, content, name);

  articles.add(article);
  return id;
}
```

2. 게시물 작성자가 아닌 경우 게시물 수정, 삭제가 안되도록 권한처리

순서: 로그인 -> MemberController의 loginIsSucess 되면 rq의 setSessionAttr에서 "loginedMember"이름으로 member객체 주소를 저장
-> Rq의 setSessionAttr에 키, 값 형태로 저장됨(Session에서 put을 통해 SessionData에 저장됨) 
-> ArticleController에서 member에 session.getAttribute로 "loginedMember" 이름으로 값을 가져와서 담는다
-> 저장할 때 타입 Object이므로(Object 타입은 모든 것을 타입을 수용할 수 있다) Member로 형변환
- 그러나 매번 형변환 하는 것보다 rq에 맡길 수 있도록 수정


```
public class ArticleController {
  
  // 생략
  
  // 여기서부터
  Member member = (Member) session.getAttribute("loginedMember");
  int id = articleService.write(subject, content, member.getName()); // member 이름 넘겨줌
  // 여기까지 삭제
  
  // rq에 맡김
  Member member = rq.getLoginedMember();
  // 1번회원 - getId, user1, 1234, 김철수 - getName
  int id = articleService.write(subject, content, member.getName(), member.getId()); // member.getId()를 함께 저장
  System.out.printf("%d번 게시물이 등록되었습니다.\n", id);
  }
  // 생략
    
  public void doModify(Rq rq) {
  // 생략
  // 게시물 존재 확인 -> 권한 확인
  if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }

    Member member = rq.getLoginedMember();
    if(article.getMemberId() != member.getId()) {
      System.out.println("해당 글에 권한이 없습니다.");
      return;
    }  
    System.out.print("새 제목 : ");
  // 생략
  
  public void doDelete(Rq rq) {
  // 생략
    if (article == null) {
      System.out.printf("%d번 게시물은 존재하지 않습니다.\n", id);
      return;
    }
    Member member = rq.getLoginedMember();
    if(article.getMemberId() != member.getId()) {
      System.out.println("해당 글에 권한이 없습니다.");
      return;
    }
    articleService.delete(id);
    System.out.printf("%d번 게시물은 삭제하였습니다.\n", id);
    // 생략
```
Rq 추가
```java
// 생략
// removeSessionAttr 아래 추가
public Member getLoginedMember() { // member 객체의 주소값 가져옴
    return (Member) session.getAttribute(loginedMember);
  }
```
ArticleService 일부 수정
```java
public int write(String subject, String content, String name, int memberId) {
  return articleRepository.write(subject, content, name, memberId);
}
```
ArticleRepository 일부
```java
void makeTestData() {
    IntStream.rangeClosed(1, 100)
        .forEach(i -> write("제목" + i, "내용" + i, "익명", i));
}
public int write(String subject, String content, String name, int memberId) {
  int id = ++lastId;
  Article article = new Article(id, subject, content, name, memberId);
  articles.add(article);
  return id;
}
```

### 11. 프로그램 실행되자마자 로그인된 상태


```
public class App {
// 생략
  void run() {
    System.out.println("== 자바 텍스트 게시판 시작 ==");
    // 프로그램이 실행되자마 회원 1번이 로그인 될 수 있도록.
    forTestLoginByMemberId(1); // 1을 넣었기 때문에 1번 회원 로그인 됨
    while (true) {
      Rq rq = new Rq();

      String promptName = "명령";
      if(rq.isLogined()) {
        Member loginedMember = rq.getLoginedMember();
        promptName = loginedMember.getLoginId();
      }
      System.out.printf("%s) ", promptName);
      String cmd = Container.sc.nextLine();
      rq.setCommand(cmd);
      if(!runInterceptor(rq)) {
      
      // 생략
      // runInterceptor 아래
      
      private void forTestLoginByMemberId(int id) {
        Member member = Container.memberService.findById(id);
        // 아래 코드로 인해 실행하자마자 로그인 상태
        new Rq().login(member); // Rq 객체를 만들어 member를 넣은 login 메서드 실행, 비어있는 생성자 메서드 필요
      }
    }
```

MemberService 추가
```java
// 생략
// findByLoginId 아래
public Member findById(int id) {
  return memberRepository.findById(id);
}
```
MemberRepository 추가
```java
// 생략
// findByLoginId 아래
public Member findById(int id) {
  return members.stream()
          .filter(member -> member.getId() == id)
          .findFirst()
          .orElse(null);
}
```

Rq 일부
```
// 생략
public Session session;

// 여기서부터
  public String loginedMember = "loginedMember";
  public Rq(String url) {
    this.url = url;
    params = Util.getParamsFromUrl(this.url);
    urlPath = Util.getPathFromUrl(this.url);
// 여기까지 삭제

  public String loginedMember;

  public Rq() {
    session = Container.session;
    loginedMember = "loginedMember";
  }
  public void setCommand(String url) {
    params = Util.getParamsFromUrl(url);
    urlPath = Util.getPathFromUrl(url);
  }
  public int getIntParam(String paramName, int defaultValue) {
  // 생략
  public Member getLoginedMember() {
    return (Member) session.getAttribute(loginedMember);
  }
  
  // 저장하는 login 메서드 구현. 
  public void login(Member member) {
    setSessionAttr(loginedMember, member);
  }
  public void logout() {
    removeSessionAttr(loginedMember);
  }
}
```

MemberController 수정
```
// doLogin 메서드 중
    if(loginIsSuccess) {
      System.out.printf("\"%s\"님 로그인 되었습니다.\n", loginId);

      // 삭제 rq.setSessionAttr("loginedMember", member);
      rq.login(member);
    }
    // 생략
  public void doLogout(Rq rq) {
    // 삭제 rq.removeSessionAttr("loginedMember");
    rq.logout();

    System.out.println("로그아웃 되었습니다.");
  }
```

## 이후 코드 정리 없음

~70강까지 마무리

---
71~79강(코드 반영 73강까지 완료)
### 12. board 관련

1 게시판 - 자유게시판
2 게시판 - 공지사항 게시판

자유게시판에 글 작성 /usr/article/write?boardId=1

공지사항 게시판에 글 작성 /usr/article/write?boardId=2

- 실제 boardId가 게시물 작성시 게시물 객체에 반영되도록 구현
- Article 클래스에 boardId 필드 추가
- list, detail 시 몇 번 게시판 번호인지 출력되도록
- 유효성 검사: boardId에 1 또는 2 이외의 숫자 입력 시 '존재하지 않는 게시판 번호입니다.' 출력

1. Article 클래스에 boardId 필드 추가
2. board, boardService, boardRepository 반영

### 13. 기타 기능
1. 현재 날짜 저장을 위해 Util에 getNowDateStr() 도입
2. 게시물리스트에서, 게시글이 속한 게시판명과 작성자 표시
3. 게시물리스트에서 게시판 별로 필터링하는 기능 구현
4. 게시물리스팅에서 제목검색, 본문검색
5. 게시물리스팅에서 검색조건에 해당하는 게시물 개수 표시
6. 조회수 기능 구현
7. 게시물 리스트에 페이징 기능 구현



