자바의 정석 기초편 요약 중 **객체지향** 파트 1-1~2-3까지 정리

목차
[1-1. 객체지향언어란, 클래스와 객체](#1-객체지향언어란-클래스와-객체)


링크
[추상클래스와 인터페이스](https://hyper-star-6be.notion.site/46-14aa1aae69628030be0ce9d9f750119f?pvs=4)

---

### 1. 객체지향언어란, 클래스와 객체

- 클래스와 객체
  클래스: 객체를 정의하고 객체를 생성하는데 사용=설계도
  객체(인스턴스): 속성과 기능 존재, 객체는 인스턴스를 포함하는 의미
  인스턴스화: 클래스로부터 인스턴스(객체)를 생성하는 과정
- 객체의 구성요소 속성과 기능
  속성: 변수 = 명사(크기, 높이)
  기능: 메서드 = 동사(켜기, 끄기)
  클래스를 정의할 때 객체의 속성은 변수로 기능은 메서드로 정의
- 인스턴스의 생성과 사용
  Tv t = new Tv(); // 클래스명 참조변수명 = new 클래스명();
  객체를 다루기 위한 참조변수를 선언하고 객체를 new 하여 생성 후 생성된 객체의 주소를 참조변수에 저장
  하나의 인스턴스를 여러 개의 참조변수가 가리키는 경우(가능) = 하나의 티비를 여러 개의 리모콘으로 조종
  여러 개의 인스턴스를 한 개의 참조변수가 가리키는 경우(불가능) = 여러 개의 티비를 하나의 리모콘으로 조종
- 클래스의 또 다른 정의
  변수: 하나의 데이터를 저장할 수 있는 공간
  배열: 같은 타입의 여러 데이터를 저장할 수 있는 공간
  클래스: 데이터와 함수의 결합
- 객체 생성 -> 객체 속성, 기능에 접근
  **함수 앞에 static 키워드를 붙이면 객체화 하지 않고
  해당 객체에 기능을 사용할 수 있다**


```java
class Main {
  public static void main(String[] args) {
    // static : 정적
    Person p1 = new Person();
    p1.age = 10;
    p1.name = "김철수";

    Person p2 = new Person();
    p2.age = 20;
    p2.name = "박철";

    Person p3 = new Person();
    p3.age = 30;
    p3.name = "최유리";

    System.out.println(p1.age);
    System.out.println(p2.age);
    System.out.println(p3.age);

    Person.인류평균나이 = (p1.age + p2.age + p3.age) / 3;
    p3.인류평균나이소개();
  }
}

class Person {
  // static 키워드가 붙은 변수, 메서드는 공공재가 된다.
  int age; // 인스턴스 변수
  String name;

  static int 인류평균나이;

  static void 인류평균나이소개() {
    System.out.printf("사람의 평균 나이는 %d살입니다.\n", 인류평균나이);
  }

  static void 자기소개() {  }
}
```

- 다형성: 객체의 자동형변환과 수동형변환
1. 자바에서 안전하다고 느끼는건 자동형변환을 허용해준다.
2. 자바가 위험하다고 생각하는 것, 리모콘의 형태변환이 절대로 금지되어 있다.
3. 자바가 객체의 리모컨 버튼이 제거되는 거에 대해서는 자동형변환을 허용해준다.
단, 리모콘의 버튼이 추가되는 경우에는 위험하다고 생각한다.
4. 자바는 컴파일 타임에 해당 변수에 어떤 객체의 리모콘이 있는지 모른다.
5. 위험할 때는 개발자의 사인이 필요하다. -> 수동형변환
6. 단, 수동형변환이 모든 문제를 해결해 주는건 아니기에 상환을 봐 가면서 수동형변환을 해야 한다.

```java
// 문제 : 자동차 리모콘이 페라리 객체를 가리키게 한 후 해당 리모콘이 가리키고 있는 객체를 다시 페라리 리모콘으로 가리키게(참조하게) 하는 코드를 작성해주세요.

class Main {
	public static void main(String[] args) {
		// `a페라리` 변수안의 리모콘은 버튼 개수가 3개 여야 한다.
		페라리 a페라리 = new 페라리();
		
		// `a자동차` 변수안의 리모콘은 버튼 개수가 2개 여야 한다.
		자동차 a자동차;

		// 수동형변환, 수동캐스팅
		// `a페라리`안에 있던 리모콘은 가지고 있던 버튼 3개 중에서 `뚜껑이_열리다` 버튼이 뽑힌 후 `a자동차`에 저장된다.
		a자동차 = (자동차)a페라리;
		
		// 자동형변환, 자동캐스팅
		// 자바가 판단하기에 안전한 경우만 자동형변환이 가능하다.
		// 리모콘의 버튼 개수를 줄이는 경우는 언제나 안전하다.
		a자동차 = a페라리;
		
		// 아래에서는 `a자동차`변수에 들어있던 리모콘에 `뚜껑이_열리다` 버튼이 추가된다.
		// 자바에서는 리모콘에 버튼이 빠지는건 상관하지 않지만 추가되는건 굉장히 무서워 한다.
		// 왜냐하면 추가된 버튼에 해당된 기능이 연결된 객체에 없을 수도 있기 때문이다.
		// 그렇기 때문에 여기서는 무조건 수동형변환을 사용한다.
		// 수동형변환을 사용하는 이유는 자바에게 개발자의 의도(이게 실수가 아니라는 뜻)를 명확히 밝히는 것과 같다.
		페라리 a페라리2 = (페라리)a자동차;
	}
}
class 자동차 {
	void 달리다() {}
	void 서다() {}
}
class 페라리 extends 자동차 {
	void 뚜껑이_열리다() {}
}
```




- 생성자 메서드: 객체 생성 시 딱 한 번 실행
```java
class Main {
public static void main(String[] args) {
사람 a김철수 = new 김철수();
System.out.println("== 김철수 자기소개 ==");
System.out.printf("나이 : %d\n", a김철수.나이); // 20
System.out.printf("이름 : %s\n", a김철수.이름); // 김철수

    사람 a김영희 = new 김영희();
    System.out.println("== 김영희 자기소개 ==");
    System.out.printf("나이 : %d\n", a김영희.나이); // 25
    System.out.printf("이름 : %s\n", a김영희.이름); // 김영희
}
}

class 사람 {
int 나이;
String 이름;

사람() {
this.나이 = 20;
}
}

class 김철수 extends 사람 {
// 생성자 메서드 : 객체 생성시 딱 한번 실행된다.
김철수() {
this.이름 = "김철수";
}
}

class 김영희 extends 사람 {
김영희() {
this.이름 = "김영희";
}
}
```

### 2. 변수와 메서드, 메서드 오버로딩

- 변수
```java
  class a {
  int b; // 인스턴스 변수 <- 인스턴스 생성시 '참조변수.인스턴스변수명'
  static int c; // 클래스변수(static) <- 클래스가 메모리에 올라갈 때(실행될 때)
  // '클래스이름.클래스변수명'
  }
   void method( ){ int a; // 지역변수 
    }
```

- 메서드

```java
  int add(int a, int b){ // 리턴타입 메서드이름 (타입 매개변수명, ..)
  int result = a+b;
  return result; // 함수는 리턴을 만나면 그 즉시 종료된다.
}
```

메서드 종료: return을 만났을 때
메서드 호출: 참조변수.메서드 이름(값1, 값2, ...);
인스턴스 메서드: 인스턴스 생성 후 '참조변수.메서드이름()'으로 호출
클래스 메서드(static): 객체생성없이 '클래스이름.메서드이름()'으로 호출
메서드 오버로딩: 하나의 클래스에 같은 이름의 메서드를 여러 개 정의함
- 메서드 이름이 같아야함
- 매개변수의 개수 또는 타입이 달라야 함
- 매개변수는 같고 리턴타입이 다른 경우 오버로딩 성립x

```java
int add(int a, int b) { return a + b; }
long add(long a, long b) { return a + b; }
int add(int[] a) {
  int result = 0;
  for(int i = 0; i < a.length; i++) { return a[i]; }
  return result;
}
```

- JVM 메모리 구조
  메서드 영역 <- 클래스 정보와 클래스 변수가 저장됨
  스택 <- 메서드 작업공간. 메서드 호출 시 메모리공간 할당 받고 메서드 종료 시 반환
  힙 <- 인스턴스 생성되는 공간. new연산자로 생성되는 배열과 객체 모두 여기에


- 생성자 메서드는 매개변수를 다르게 받는 생성자 메서드로 여러 개 생성 가능
- 메서드 오버로딩: 동일한 메서드명이 있어도 다른 매개변수를 주는 메서드라면 생성 가능
- **super**를 통해 부모가 가진 생성자 메서드 가져옴
```java
class Main {
  public static void main(String[] args) {
    new 동물();
    동물 a동물1 = new 동물(20);
    동물 a동물2 = new 동물(20, "콩이");

    new 사람();
//    사람 사람1 = new 사람();
//    사람1.숨쉬다();

    a동물2.숨쉬다();
    a동물2.숨쉬다("감자");
  }
}

class 동물 {
  int 나이;
  String 이름;

  // 메서드 오버로딩
  동물() {
    System.out.println("동물() 실행됨!");
  }

  // 2번
  동물(int 나이) {
    System.out.println("동물(int 나이) 실행됨!!");
  }

  // 3번
  동물(int 나이, String 이름) {
    System.out.println("동물(int 나이, String 이름) 실행됨!!");
  }

  void 숨쉬다() {
    System.out.println("숨을 쉽니다.");
  }

  void 숨쉬다(String 이름) {
    System.out.printf("%s가 숨을 쉽니다.", 이름);
  }
}

class 사람 extends 동물 {
  사람() {
    // super(); // 부모 생성자 메서드 실행
    // super(10);
    super(10, "쌀이");
    System.out.println("사람() 실행됨!");
  }

  void 숨쉬다() {
    super.숨쉬다(); // 부모 안에 정의된 숨쉬다 메서드 호출
  }
}
```



### 3. 생성자, 변수의 초기화

생성자(Constructor): 
- 인스턴스가 생성될 때마다 호출되는 **인스턴스 초기화 메서드**
- **모든 클래스에는 반드시 하나 이상의생성자가 있어야 한다**
- 인스턴스 초기화 = 인스턴스 변수에 적절한 값을 저장하는 것
- 생성자는 클래스 이름과 같고 리턴값이 없다(void도 x)

```java
class Card {
  String kind;
  int num;
}

Card() {// 기본 생성자 = 매개변수가 없는 생성자
  // 인스턴스 초기화
  }
Card(String k, int n) {// 매개변수가 있는 생성자
  // 인스턴스 초기화
  kind = k;
  num = n;
}

Card() {
  // Card("check", 1);
  this("check", 1);
  // this() 사용하여 코드의 재사용성 높임
}

Card(String kind, int num){
  // 참조변수 this
  // 인스턴스 변수와 지역변수를 구분하기 위해
  this.kind = kind;
  this.num = num;
}

// 생성자를 이용한 인스턴스 복사
Card(Card c){
  this(c.kind, c.num);
}

class CardTest {
  public static void main(String[] args) {
    Card c1 = new Card();
/*
    1. 연산자 new에 의해 메모리(heap)에 Card클래스의 인스턴스가 생성된다
    2. 생성자 Card()가 호출되어 수행된다
    3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다
 */
    Card c2 = new Card("check", 1); // 아래와 같다
// Card c = new Card();
// c.kind = "check";
// c.num = 1;

    Card c3 = new Card(c1); // Card(Card c)를 호출하여 생성자를 이용한 인스턴스 복사
     }
}
```

this()
- 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용.
- 다른 생성자 호출은 생성자의 첫 문장에서만 가능

참조변수 this
- 인스턴스 자신을 가리키는 참조변수
- 인스턴스의 주소가 저장되어있음
- 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재

생성자를 이용한 인스턴스의 복사
- 인스턴스 간의 차이는 인스턴스 변수의 값 뿐. 나머지는 동일
- 생성자에서 참조변수를 매개변수로 받아서 인스턴스 변수들의 값을 복사
- 똑같은 속성값을 갖는 독립적인 인스턴스가 하나 더 만들어짐

변수의 초기화
- 변수를 선언하고 처음으로 값을 저장하는 것
- 멤버변수(인스턴스변수, 클래스 변수)와 배열은 각 타입의 기본값으로 자동 초기화 되므로 초기화 생략 가능
- 지역 변수는 사용 전 반드시 초기화 해야함

멤버변수의 초기화
1. 명시적 초기화
```java
class Car {
  int door = 4; // 기본형 변수 초기화
  Engine e = new Engine(); // 참조형 변수 초기화
}
```

2. 생성자
```java
Car(String color, String gearType, int door) {
  this.color = color;
  this.gearType = gearType;
  this.door = door;
}
```
3. 초기화 블록
- 인스턴스 초기화 블록: { }
  - 생성자에서 공통적으로 수행되는 작업에 사용되며 생성자가 생성될 때마다 생성자보다 먼저 실행
- 클래스 초기화 블록: static { }
    - 클래스 변수의 복잡한 초기화에 사용되며 클래스가 로딩될 때 실행됨

멤버변수의 초기화 시기와 순서
- 클래스변수 초기화 시점: 클래스가 처음 로딩될 때 딱 한 번
- 인스턴스변수 초기화 시점: 인스턴스가 생성될 때마다
```java
class InitTest {
  static int cv = 1; // 명시적 초기화
  int iv = 1; // 명시적 초기화
  static { cv = 2; } // 클래스 초기화 블록
  { iv = 2; } // 인스턴스 초기화 블록: 모든 생성자에서 공통적으로 수행
  InitTest() { // 생성자
    iv = 3;
  }
}

IniTest it = new InitTest();
```

### 4. 상속, 오버라이딩

상속(inheritance): ~은 ~이다.(is-a)
- 기존의 클래스를 재사용해서 새로운 클래스를 작성
- 자손은 조상의 모든 멤버를 상속받음(생성자, 초기화 블록 제외)
- 공통부분은 조상에서 관리. 개별부분은 자손에서 관리

포함(composite): ~은 ~을 가지고 있다.(has-a)
- 한 클래스의 멤버변수로 다른 클래스를 선언
- 작은 단위의 클래스를 먼저 만들고, 이들을 조합해서 하나의 커다란 클래스를 만듦
```java
class Point {
  int x; // x좌표
  int y; // y좌표
}
class Circle {
  Point c = new Point();
  int r; // 반지름
}
```
자바는 단일 상속만을 허용한다
- 비중이 높은 크래스만 상속관계
- 나머지 포함관계로

```java
class Tv{
  boolean power;
  int channel;
  void power() {power = !power;}
  void channelUp() {++channel;}
  void channelDown() {--channel;}
}

class VCR {
  boolean power;
  int counter = 0;
  void power() {power = !power;}
  void play() {}
  void stop() {}
  void rew() {}
  void ff() {}
}

class TVCR extends Tv {
  VCR vcr = new VCR();
  
  void play() {
    vcr.play();
  }
  void stop() {
    vcr.stop();
  }
  void rew() {
    vcr.rew();
  }
  void ff() {
    vcr.ff();
  }
}
```

Object 클래스
- 모든 클래스의 최고 조상
- toString() ,equals(Object obj), hashCode(), ... 총 11개 메서드
- 모든 클래스는 Object 클래스를 상속 받음


오버라이딩: 조상클래스로부터 상속받은 메서드의 내용을 상속받은 클래스에 맞게 변경하는 것
조건
1. 선언부가 같아야 함(이름, 매개변수, 리턴타입)
2. 접근제어자를 좁은 범위로 변경할 수 없다
- 조상 메서드 protected 라면, protected 나 public 으로만 변경 가능
3. 조상클래스의 메서드보다 많은 수의 예외 선언 불가

오버로딩 vs. 오버라이딩
- 오버로딩: 기존에 없는 새로운 메서드를 정의(new)
- 오버라이딩: 상속받은 메서드의 내용을 변경(change, modify)


### 5. 제어자 총정리
1. static: 클래스가 메모리에 로드될 때 생성. 인스턴스를 생성하지 않고 사용 가능
2. final: 변경될 수 없음. 고정값.
3. abstract: 추상메서드 선언 시 사용. 선언부만 작성하고 구현하지 않은 추상메서드.
```java
abstract class Test { // 추상클래스
  abstract void move(); // 추상메서드
}
```
4. private: 같은 클래스 내에서만 접근 가능
5. default: 같은 패키지 내에서만 접근 가능
6. public: 접근 제한 없음
7. protected: 같은 패키지 내, 다른 패키지의 자손클래스에서 접근 가능




















